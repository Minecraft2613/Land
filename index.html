<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Land Registry</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
    <script src="noise.js"></script>
</head>

<body>

    <div class="container">
        <!-- Login Page -->
        <section id="login-view" class="view-section active">
            <div class="form-container">
                <h1 style="text-align: center; font-size: 2rem;">Land Registry</h1>
                <p style="text-align: center; color: var(--text-muted); margin-bottom: 2rem;">Secure plots for your
                    server.</p>
                <form id="login-form">
                    <div class="form-group">
                        <label for="edition">Platform Edition</label>
                        <select id="edition" name="edition">
                            <option value="Java">Java Edition</option>
                            <option value="Bedrock">Bedrock Edition</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="name">Gamertag / Username</label>
                        <input type="text" id="name" name="name" placeholder="Stevie123" required>
                    </div>
                    <button type="submit" class="button login-button"
                        style="width: 100%; justify-content: center;">Authenticate</button>
                    <div id="messages" class="messages"></div>
                </form>
            </div>
        </section>

        <!-- Dashboard Page -->
        <section id="dashboard-view" class="view-section">
            <header class="app-header">
                <div>
                    <h1 id="dashboard-title">Dashboard</h1>
                    <p style="color: var(--text-muted);">Manage your real estate.</p>
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button id="buy-land-button" class="button">
                        <span style="font-size: 1.2rem;">+</span> Buy Land
                    </button>
                    <button id="gov-panel-button" class="button"
                        style="display: none; background: linear-gradient(135deg, #f59e0b, #d97706);">Gov Panel</button>
                    <button id="logout-button" class="button logout-button">Log Out</button>
                </div>
            </header>

            <div id="user-lands-list" class="card-grid"></div>
            <div id="dashboard-messages" class="messages"></div>
        </section>

        <!-- Buy Land Page -->
        <section id="buy-land-view" class="view-section">
            <header class="app-header">
                <h1>Purchase Plot</h1>
                <button id="back-from-buy-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container">
                <form id="buy-land-form">
                    <p style="margin-bottom: 1rem; color: var(--text-muted); font-size: 0.9rem;">Enter coordinates for
                        two opposite corners (X, Z). Y is automatically set to 1.</p>
                    <div class="form-grid">
                        <!-- Coordinates will be generated here -->
                    </div>

                    <div id="live-calculation-card"
                        style="display: none; margin-top: 1.5rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 0.5rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-muted);">Area</span>
                            <span style="font-weight: 700;"><span id="calc-blocks">0</span> blocks</span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">Base</span>
                            <span>$<span id="calc-base-cost">0.00</span></span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">Tax (10%)</span>
                            <span>$<span id="calc-tax">0.00</span></span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">GST (3%)</span>
                            <span>$<span id="calc-gst">0.00</span></span>
                        </div>
                        <div
                            style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 0.5rem; padding-top: 0.5rem; display: flex; justify-content: space-between; color: var(--success);">
                            <span style="font-weight: 700;">TOTAL</span>
                            <span style="font-weight: 700; font-size: 1.2rem;">$<span
                                    id="calc-total-cost">0.00</span></span>
                        </div>
                    </div>

                    <button type="submit" class="button login-button"
                        style="width: 100%; justify-content: center; margin-top: 1.5rem;">Confirm Reservation</button>
                    <div id="buy-land-messages" class="messages"></div>
                </form>
            </div>
        </section>

        <!-- Government Panel Page -->
        <section id="gov-panel-view" class="view-section">
            <header class="app-header">
                <h1>Government Admin</h1>
                <button id="back-from-gov-button" class="button logout-button">Back</button>
            </header>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 3rem;">
                <div class="land-card">
                    <h3>Global Settings</h3>
                    <form id="gov-settings-form">
                        <div class="form-group">
                            <label for="gov-gap">Plot Buffer (Blocks)</label>
                            <input type="number" id="gov-gap" name="gov-gap" required>
                        </div>
                        <div class="form-group">
                            <label for="gov-land-type">Reserved Land Label</label>
                            <input type="text" id="gov-land-type" name="gov-land-type" required>
                        </div>
                        <button type="submit" class="button">Apply Config</button>
                    </form>
                </div>

                <div class="land-card">
                    <h3>Zone Registration</h3>
                    <form id="register-gov-land-form">
                        <div class="form-group">
                            <label for="gov-land-gap">Player Gap Requirement</label>
                            <input type="number" id="gov-land-gap" name="gov-land-gap" required>
                        </div>
                        <div class="form-grid"></div>
                        <button type="submit" class="button" id="register-gov-land-button"
                            style="margin-top: 1rem;">Register Zone</button>
                    </form>
                </div>
            </div>

            <div id="gov-panel-messages" class="messages"></div>

            <div class="land-card" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem;">Treasury</h3>
                <div style="font-size: 2rem; font-weight: 700; color: var(--success);">$<span
                        id="gov-balance">0.00</span></div>
            </div>

            <h3
                style="margin-bottom: 1rem; color: var(--text-muted); text-transform: uppercase; font-size: 0.8rem; letter-spacing: 0.1em;">
                Player Management</h3>
            <div id="player-management-section">
                <div id="owner-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem;">
                </div>
                <div id="selected-player-plots" class="card-grid"></div>
            </div>
        </section>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p id="loading-message" style="font-weight: 500;">Processing Request...</p>
    </div>

    <!-- Payment Status Overlay (Only for final success/failure result, not pending) -->
    <div id="payment-status-overlay" style="display: none;">
        <div id="payment-status-icon"></div>
        <p id="payment-status-message"></p>
        <button id="payment-status-close" class="button">Close</button>
    </div>

    <script>
        // Constants & Config
        const MAX_PLAYER_LAND_BLOCKS = 144000000000;
        const PLAYER_PLOT_GAP = 7;
        const API_URL = 'https://land.1987sakshamsingh.workers.dev';
        const WORLD_SEED = 67480912992;

        // DOM Elements
        const loginForm = document.getElementById('login-form');
        const loginMessages = document.getElementById('messages');
        const dashboardTitle = document.getElementById('dashboard-title');
        const logoutButton = document.getElementById('logout-button');
        const buyLandButton = document.getElementById('buy-land-button');
        const govPanelButton = document.getElementById('gov-panel-button');
        const userLandsList = document.getElementById('user-lands-list');
        const dashboardMessages = document.getElementById('dashboard-messages');
        const buyLandForm = document.getElementById('buy-land-form');
        const buyLandMessages = document.getElementById('buy-land-messages');
        const backFromBuyButton = document.getElementById('back-from-buy-button');
        const govSettingsForm = document.getElementById('gov-settings-form');
        const registerGovLandForm = document.getElementById('register-gov-land-form');
        const govPanelMessages = document.getElementById('gov-panel-messages');
        const backFromGovButton = document.getElementById('back-from-gov-button');
        const ownerButtonsContainer = document.getElementById('owner-buttons');
        const selectedPlayerPlotsContainer = document.getElementById('selected-player-plots');
        const paymentStatusOverlay = document.getElementById('payment-status-overlay');
        const buyLandSubmitButton = buyLandForm.querySelector('button[type="submit"]');
        const registerGovLandSubmitButton = registerGovLandForm.querySelector('button[type="submit"]');
        const views = document.querySelectorAll('.view-section');

        // State
        let currentUser = null;
        let users = [];
        let lands = [];
        let govConfig = { gap: 10, landType: 'Government' };
        let governmentBalance = 0;
        let selectedPlayerForManagement = null;
        let hasPendingPayment = false;
        let landCardTimers = {};

        // --- Core Functions ---

        async function loadData() {
            try {
                const response = await fetch(`${API_URL}/data`);
                if (!response.ok) throw new Error('API Error');
                const data = await response.json();
                users = data.users || [];
                lands = data.lands || [];
                govConfig = data.govConfig || { gap: 10, landType: 'Government' };
                governmentBalance = data.governmentBalance || 0;
            } catch (e) {
                console.error("Load failed:", e);
            }
        }

        async function saveData() {
            try {
                const response = await fetch(`${API_URL}/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ users, lands, govConfig, governmentBalance })
                });
                return await response.json();
            } catch (e) {
                console.error("Save failed", e);
                throw e;
            }
        }

        // --- Terrain Map System ---

        // Better Seeded PRNG that handles 64-bit seeds better
        function splitmix64(seed) {
            let s = BigInt(seed);
            return function () {
                s += BigInt(0x9e3779b97f4a7c15);
                let z = s;
                z = (z ^ (z >> BigInt(30))) * BigInt(0xbf58476d1ce4e5b9);
                z = (z ^ (z >> BigInt(27))) * BigInt(0x94d049bb133111eb);
                z = z ^ (z >> BigInt(31));
                return Number(z & BigInt(0xFFFFFFFF)) / 4294967296;
            }
        }

        let terrainNoise = null;
        let biomeNoise = null;
        let weirdnessNoise = null;

        function initNoise() {
            if (!terrainNoise) {
                const rng = splitmix64(WORLD_SEED);
                terrainNoise = new ClassicalNoise(rng);
                const rng2 = splitmix64(WORLD_SEED + 123456789);
                biomeNoise = new ClassicalNoise(rng2);
                const rng3 = splitmix64(WORLD_SEED ^ 0xABCDEF);
                weirdnessNoise = new ClassicalNoise(rng3);
            }
        }

        // Refined FBM with lower frequency for world-scale accuracy
        function fbm(x, z, octaves, frequency = 0.0005) {
            let total = 0;
            let amp = 1;
            let freq = frequency;
            let max = 0;
            for (let i = 0; i < octaves; i++) {
                total += terrainNoise.noise(x * freq, 1.5, z * freq) * amp;
                max += amp;
                amp *= 0.5;
                freq *= 2;
            }
            return (total / max) + 0.5;
        }

        function getNoise(x, z) {
            initNoise();
            
            // 1. Continentalness (Huge scale: Land vs Deep Ocean)
            const cont = fbm(x, z, 5, 0.0004); 
            
            // 2. Erosion (Flat vs Rugged)
            const erosion = fbm(x + 5000, z + 5000, 4, 0.001);
            
            // 3. Weirdness (Used for Rivers and Varied Biomes)
            const weird = weirdnessNoise.noise(x * 0.0012, 0, z * 0.0012) + 0.5;
            
            // 4. Biome Factors (Temp/Humidity)
            const temp = biomeNoise.noise(x * 0.0008, 10, z * 0.0008) + 0.5;
            const humid = biomeNoise.noise(x * 0.0008, 50, z * 0.0008) + 0.5;
            
            // River Detection: Rivers occur in "valleys" of weirdness
            const isRiverVal = Math.abs(weird - 0.5) < 0.035 && cont > 0.45;

            // Final Height Calculation
            let h = cont;
            if (isRiverVal) {
                h -= 0.08; // Carve the river
            } else if (h > 0.5) {
                // Mountain influence based on erosion
                const peak = Math.max(0, fbm(x, z, 3, 0.005) - 0.5) * 2;
                h += peak * (1.0 - erosion) * 0.4;
            }

            return { height: h, temp, humid, erosion, weird, isRiver: isRiverVal };
        }

        function renderTerrainMap(canvasId, land) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            initNoise();

            const rect = canvas.getBoundingClientRect();
            const width = Math.floor(rect.width) || 300;
            const height = Math.floor(rect.height) || 250;
            canvas.width = width;
            canvas.height = height;

            const c1 = land.coords[0];
            const c2 = land.coords[1];
            const pMinX = Math.min(c1.x, c2.x);
            const pMaxX = Math.max(c1.x, c2.x);
            const pMinZ = Math.min(c1.z, c2.z);
            const pMaxZ = Math.max(c1.z, c2.z);

            const plotW = pMaxX - pMinX + 1;
            const plotD = pMaxZ - pMinZ + 1;
            const plotCenterX = pMinX + (plotW / 2);
            const plotCenterZ = pMinZ + (plotD / 2);

            // Zoom logic: Smaller plots show more context
            const maxDim = Math.max(plotW, plotD);
            let viewRadius = Math.max(40, maxDim * 1.6);
            if (maxDim > 100) viewRadius = maxDim * 1.1;

            const isoScale = width / (viewRadius * 2.5);
            const cx = width / 2;
            const cy = height / 2;

            const toScreen = (x, y, z) => {
                const dx = x - plotCenterX;
                const dz = z - plotCenterZ;
                return {
                    x: cx + (dx - dz) * isoScale,
                    y: cy + ((dx + dz) * isoScale * 0.5) - (y * isoScale * 0.7)
                };
            };

            const renderDist = Math.ceil(width / isoScale) + 4;
            const rMinX = Math.floor(plotCenterX - renderDist);
            const rMaxX = Math.floor(plotCenterX + renderDist);
            const rMinZ = Math.floor(plotCenterZ - renderDist);
            const rMaxZ = Math.floor(plotCenterZ + renderDist);

            ctx.clearRect(0, 0, width, height);

            const seaLevel = 0.48;

            for (let sum = rMinX + rMinZ; sum <= rMaxX + rMaxZ; sum++) {
                for (let x = rMinX; x <= rMaxX; x++) {
                    const z = sum - x;
                    if (z < rMinZ || z > rMaxZ) continue;

                    const n = getNoise(x, z);
                    const isActuallyWater = n.height < seaLevel;
                    const terrainY = (n.height - seaLevel) * 40;
                    const visualY = isActuallyWater ? 0 : terrainY;

                    const s = toScreen(x, visualY, z);
                    if (s.x < -isoScale * 2 || s.x > width + isoScale * 2 || s.y < -isoScale * 2 || s.y > height + isoScale * 2) continue;

                    // Biome Colors (Minecraft 1.21-ish)
                    let r, g, b;
                    if (n.height < 0.4) { [r, g, b] = [20, 50, 120]; } // Deep Ocean
                    else if (isActuallyWater) { 
                        if (n.isRiver) [r, g, b] = [60, 130, 200]; // River Blue
                        else [r, g, b] = [40, 80, 180]; // Regular Ocean
                    }
                    else if (n.height < seaLevel + 0.015) { [r, g, b] = [220, 200, 140]; } // Beach/Sand
                    else if (n.height > 0.85) { [r, g, b] = [255, 255, 255]; } // Snow Peaks
                    else if (n.height > 0.75) { [r, g, b] = [130, 130, 140]; } // Stony Peaks
                    else {
                        // Land biomes based on Temp/Humid
                        if (n.temp > 0.8) {
                            if (n.humid < 0.4) [r, g, b] = [210, 185, 100]; // Desert
                            else [r, g, b] = [40, 100, 30]; // Jungle
                        } else if (n.temp < 0.3) {
                            [r, g, b] = [120, 150, 120]; // Tundra/Taiga
                        } else {
                            if (n.humid > 0.7) [r, g, b] = [30, 70, 40]; // Dark Forest
                            else if (n.humid < 0.35) [r, g, b] = [140, 170, 70]; // Plains
                            else [r, g, b] = [70, 140, 50]; // Forest
                        }
                    }

                    // Shading (Slope-based)
                    const nW = getNoise(x - 1, z).height;
                    const nN = getNoise(x, z - 1).height;
                    const shade = 1.0 + (n.height - nW) * 2.0 + (n.height - nN) * 2.0;

                    const topColor = `rgb(${r * shade}, ${g * shade}, ${b * shade})`;
                    const leftColor = `rgb(${r * 0.65 * shade}, ${g * 0.65 * shade}, ${b * 0.65 * shade})`;
                    const rightColor = `rgb(${r * 0.8 * shade}, ${g * 0.8 * shade}, ${b * 0.8 * shade})`;

                    const sideH = isActuallyWater ? (seaLevel - n.height) * 15 : 4 + terrainY;

                    // Sides
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y + isoScale);
                    ctx.lineTo(s.x + isoScale, s.y + isoScale * 0.5);
                    ctx.lineTo(s.x + isoScale, s.y + isoScale * 0.5 + sideH * isoScale * 0.5);
                    ctx.lineTo(s.x, s.y + isoScale + sideH * isoScale * 0.5);
                    ctx.fillStyle = rightColor; ctx.fill();

                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y + isoScale);
                    ctx.lineTo(s.x - isoScale, s.y + isoScale * 0.5);
                    ctx.lineTo(s.x - isoScale, s.y + isoScale * 0.5 + sideH * isoScale * 0.5);
                    ctx.lineTo(s.x, s.y + isoScale + sideH * isoScale * 0.5);
                    ctx.fillStyle = leftColor; ctx.fill();

                    // Top
                    ctx.beginPath();
                    ctx.moveTo(s.x, s.y);
                    ctx.lineTo(s.x + isoScale, s.y + isoScale * 0.5);
                    ctx.lineTo(s.x, s.y + isoScale);
                    ctx.lineTo(s.x - isoScale, s.y + isoScale * 0.5);
                    ctx.fillStyle = topColor; ctx.fill();
                }
            }

            // --- Plot Boundaries ---
            lands.forEach(l => {
                const isMyLand = (l.owner === currentUser.minecraftName);
                const isCurrentPlot = (l === land);

                const lx1 = Math.min(l.coords[0].x, l.coords[1].x);
                const lx2 = Math.max(l.coords[0].x, l.coords[1].x) + 1;
                const lz1 = Math.min(l.coords[0].z, l.coords[1].z);
                const lz2 = Math.max(l.coords[0].z, l.coords[1].z) + 1;

                if (lx2 < rMinX || lx1 > rMaxX || lz2 < rMinZ || lz1 > rMaxZ) return;

                let strokeStyle = isMyLand ? '#4ade80' : '#f87171';
                if (isCurrentPlot) strokeStyle = '#fbbf24';

                const getH = (x, z) => {
                    const h = getNoise(x, z).height;
                    return Math.max(0, (h - seaLevel) * 35);
                };

                ctx.lineWidth = isCurrentPlot ? 3 : 2;
                ctx.strokeStyle = strokeStyle;
                ctx.setLineDash(isCurrentPlot ? [] : [5, 5]);

                const h1 = getH(lx1, lz1) + 1;
                const h2 = getH(lx2, lz1) + 1;
                const h3 = getH(lx2, lz2) + 1;
                const h4 = getH(lx1, lz2) + 1;

                const p1 = toScreen(lx1, h1, lz1);
                const p2 = toScreen(lx2, h2, lz1);
                const p3 = toScreen(lx2, h3, lz2);
                const p4 = toScreen(lx1, h4, lz2);

                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);

                if (isCurrentPlot || isoScale > 12) {
                    const pC = toScreen((lx1 + lx2) / 2, Math.max(h1, h2, h3, h4) + 6, (lz1 + lz2) / 2);
                    ctx.fillStyle = 'white';
                    ctx.font = '900 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowColor = 'black';
                    ctx.shadowBlur = 6;
                    ctx.fillText(l.owner.toUpperCase(), pC.x, pC.y);
                    ctx.shadowBlur = 0;
                }
            });
        }


        // --- UI Rendering ---

        function renderLandCard(land) {
            const isPending = !land.paid && land.paymentCode && (new Date().getTime() < land.expirationTime);
            const statusClass = land.paid ? 'status-paid' : (isPending ? 'status-pending' : 'status-expired');
            const statusText = land.paid ? 'OWNED' : (isPending ? 'RESERVED' : 'EXPIRED');
            const canvasId = `map-${land.id || land.paymentCode}`;

            const c1 = land.coords[0];
            const c2 = land.coords[1];

            return `
                <div class="land-card">
                    <canvas id="${canvasId}" class="land-map-canvas"></canvas>
                    
                    <div class="land-details">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 0.5rem;">
                            <h3>${land.landType} Plot</h3>
                            <span class="detail-value ${statusClass}" style="padding: 0.2rem 0.6rem; border-radius: 6px; background: rgba(0,0,0,0.4); font-size:0.75rem; letter-spacing:0.05em;">${statusText}</span>
                        </div>
                        
                        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <div style="background:rgba(255,255,255,0.05); padding:0.5rem; border-radius:4px;">
                                <span style="color:var(--text-muted); display:block; font-size:0.7rem;">X Range</span>
                                <span class="detail-value">${Math.min(c1.x, c2.x)} ↔ ${Math.max(c1.x, c2.x)}</span>
                            </div>
                             <div style="background:rgba(255,255,255,0.05); padding:0.5rem; border-radius:4px;">
                                <span style="color:var(--text-muted); display:block; font-size:0.7rem;">Z Range</span>
                                <span class="detail-value">${Math.min(c1.z, c2.z)} ↔ ${Math.max(c1.z, c2.z)}</span>
                            </div>
                        </div>
                        <p style="text-align:right; font-size:0.8rem; color:var(--text-muted);">Area: <span style="color:var(--text-main);">${land.blocks.toLocaleString()} m²</span></p>
                    </div>

                    ${isPending ? `
                        <div class="pending-payment-section" id="pending-section-${land.paymentCode}">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                                <h4 style="margin:0;">Payment Required</h4>
                                <span id="timer-${land.paymentCode}" class="timer-display" style="background:rgba(0,0,0,0.3); padding:0.1rem 0.4rem; border-radius:4px;">--:--</span>
                            </div>
                            
                            <div style="display:flex; gap:0.5rem; margin-bottom:0.5rem;">
                                <code style="flex-grow:1; text-align:center; padding:0.5rem; border:1px dashed var(--warning); background:rgba(245, 158, 11, 0.05); display:flex; align-items:center; justify-content:center;">/land payment ${land.paymentCode}</code>
                                <button class="button copy-button" onclick="copyCommand('${land.paymentCode}', this)" style="background:var(--bg-card); border-color:var(--glass-border); min-width:80px;">
                                    <svg xmlns="http://www.w3.org/2001/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                    Copy
                                </button>
                            </div>
                            
                            <button class="button cancel-button" style="width:100%; justify-content:center; margin-top:0.5rem;" onclick="cancelPayment('${land.paymentCode}')">Cancel Reservation</button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderDashboard() {
            if (!currentUser) return;
            setView('dashboard-view');

            dashboardTitle.textContent = `Welcome, ${currentUser.minecraftName}`;
            govPanelButton.style.display = currentUser.minecraftName.toLowerCase() === 'minecraft2613' ? 'flex' : 'none';

            // Check pending payments globally to disable button
            hasPendingPayment = lands.some(l => !l.paid && l.owner === currentUser.minecraftName && new Date().getTime() < l.expirationTime);

            buyLandButton.disabled = hasPendingPayment;
            buyLandButton.style.opacity = hasPendingPayment ? '0.5' : '1';
            buyLandButton.innerHTML = hasPendingPayment ? '<span style="font-size:1.2rem; margin-right:0.5rem;">⏳</span> One Reservation Active' : '<span style="font-size:1.2rem; margin-right:0.5rem;">+</span> Buy Land';

            // Render Cards
            const myLands = lands.filter(l => l.owner === currentUser.minecraftName);
            userLandsList.innerHTML = myLands.length ? myLands.map(renderLandCard).join('') : '<p style="grid-column: 1/-1; text-align: center; color: var(--text-muted);">You own no land. Start your empire today!</p>';

            // Post-render: Initialize Maps and Timers
            myLands.forEach(land => {
                // Render Map
                renderTerrainMap(`map-${land.id || land.paymentCode}`, land);

                // Initialize Timer if pending
                if (!land.paid && land.paymentCode && new Date().getTime() < land.expirationTime) {
                    startCardTimer(land.paymentCode, land.expirationTime);
                }
            });
        }

        // --- Logic & Timers ---

        function startCardTimer(code, expiry) {
            if (landCardTimers[code]) clearInterval(landCardTimers[code]);

            const tick = () => {
                const now = new Date().getTime();
                const left = Math.ceil((expiry - now) / 1000);
                const el = document.getElementById(`timer-${code}`);

                if (!el) { clearInterval(landCardTimers[code]); return; }

                if (left <= 0) {
                    el.textContent = "Expired";
                    clearInterval(landCardTimers[code]);
                    // Auto-refresh to show expired state
                    loadData().then(renderDashboard);
                } else {
                    const m = Math.floor(left / 60).toString().padStart(2, '0');
                    const s = (left % 60).toString().padStart(2, '0');
                    el.textContent = `${m}:${s}`;
                }
            };

            tick();
            landCardTimers[code] = setInterval(tick, 1000);

            // Poll for payment success specifically for this card
            const poller = setInterval(async () => {
                await loadData();
                const l = lands.find(x => x.paymentCode === code);
                if (!l || l.paid) {
                    clearInterval(poller);
                    clearInterval(landCardTimers[code]);
                    if (l && l.paid) showPaymentSuccess();
                    renderDashboard();
                }
            }, 3000);
        }

        async function cancelPayment(code) {
            if (!confirm("Cancel this reservation?")) return;
            showLoading("Cancelling...");
            try {
                await fetch(`${API_URL}/cancel-payment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ paymentCode: code })
                });
                await loadData();
                renderDashboard();
            } catch (e) { console.error(e); }
            hideLoading();
        }

        // --- Form Handling ---

        function copyCommand(code, btn) {
            const cmd = `/land payment ${code}`;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(cmd).then(() => {
                    const originalText = btn.innerHTML;
                    btn.innerHTML = `<span style="color:#6ee7b7; font-weight:bold;">✓ Copied</span>`;
                    btn.style.borderColor = '#10b981';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.borderColor = '';
                    }, 2000);
                });
            } else {
                // Fallback
                prompt("Copy this:", cmd);
            }
        }

        function renderBuyLand() {
            setView('buy-land-view');
            renderCoordinatesForm(buyLandForm, 2, 'player');
            // Re-attach live calc listeners which are lost on innerHTML replace
            const inputs = buyLandForm.querySelectorAll('input');
            inputs.forEach(i => i.addEventListener('input', updateLiveCalc));
        }

        function updateLiveCalc() {
            const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
            const details = calculatePlotDetails(coords);
            const card = document.getElementById('live-calculation-card');

            if (details.isValid) {
                card.style.display = 'block';
                document.getElementById('calc-blocks').textContent = details.blocks.toLocaleString();
                document.getElementById('calc-base-cost').textContent = details.baseCost.toFixed(2);
                document.getElementById('calc-tax').textContent = details.tax.toFixed(2);
                document.getElementById('calc-gst').textContent = details.gst.toFixed(2);
                document.getElementById('calc-total-cost').textContent = details.cost.toFixed(2);
            } else {
                card.style.display = 'none';
            }
        }

        // Helpers
        function renderCoordinatesForm(el, count, type) {
            let html = '';
            for (let i = 1; i <= count; i++) {
                html += `<div class="form-group"><label>Point ${i}</label><div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                 <input type="number" name="${type}-coord-x-${i}" placeholder="X" required class="coord-input">
                 <!-- Y hidden -->
                 <input type="hidden" name="${type}-coord-y-${i}" value="1">
                 <input type="number" name="${type}-coord-z-${i}" placeholder="Z" required class="coord-input">
                 </div></div>`;
            }
            el.querySelector('.form-grid').innerHTML = html;
        }
        function getFormCoordinates(el, count, prefix) {
            const arr = [];
            for (let i = 1; i <= count; i++) {
                const x = el.querySelector(`[name="${prefix}-x-${i}"]`).value;
                const y = el.querySelector(`[name="${prefix}-y-${i}"]`).value || 1;
                const z = el.querySelector(`[name="${prefix}-z-${i}"]`).value;
                arr.push({ x, y, z });
            }
            return arr;
        }

        // --- Standard Utils ---

        function setView(id) {
            views.forEach(v => v.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function showLoading(msg) {
            document.getElementById('loading-message').textContent = msg;
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        function showMessage(el, msg, type) {
            if (!el) return;
            el.textContent = msg;
            el.className = `messages message-${type}`;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 4000);
        }
        function showPaymentSuccess() {
            const overlay = document.getElementById('payment-status-overlay');
            if (overlay) {
                // Minimal success interaction
                const audio = new Audio('https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3');
                audio.play().catch(e => { }); // ignore autoplay policy
                document.getElementById('payment-status-message').textContent = "Payment Successful!";
                document.getElementById('payment-status-icon').innerHTML = '<svg xmlns="http://www.w3.org/2001/svg" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" width="64" height="64"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
                overlay.style.display = 'flex';
            }
        }

        // --- Init ---

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('name').value.trim();
            if (!name) return;

            showLoading("Authenticating...");
            await loadData();

            let user = users.find(u => u.minecraftName === name);
            if (!user) {
                user = { minecraftName: name, minecraftEdition: document.getElementById('edition').value };
                users.push(user);
                await saveData();
            }
            currentUser = user;
            hideLoading();
            renderDashboard();
        });

        // Event Listeners for Buttons
        document.getElementById('logout-button').addEventListener('click', () => { window.location.reload(); });
        document.getElementById('payment-status-close').addEventListener('click', () => { document.getElementById('payment-status-overlay').style.display = 'none'; });
        buyLandButton.addEventListener('click', renderBuyLand);
        document.getElementById('back-from-buy-button').addEventListener('click', () => setView('dashboard-view'));

        // Buy Land Submit
        buyLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            showLoading("Reserving Plot...");
            try {
                const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
                const details = calculatePlotDetails(coords); // reuse existing logic

                // Construct payload manually since verify logic is client-side here
                // Note: Production should verify server-side
                const payload = {
                    owner: currentUser.minecraftName,
                    coords: coords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) })),
                    blocks: details.blocks,
                    cost: details.cost,
                    baseCost: details.baseCost,
                    tax: details.tax,
                    gst: details.gst,
                    gap: PLAYER_PLOT_GAP,
                    landType: 'Player'
                };

                const res = await fetch(`${API_URL}/reserve-land-web`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const json = await res.json();

                if (json.success) {
                    await loadData();
                    renderDashboard();
                } else {
                    alert("Error: " + json.message);
                }
            } catch (err) {
                console.error(err);
                alert("Reservation Failed");
            }
            hideLoading();
        });

        // Init
        loadData();

        // Helpers I preserved from original code for math
        const calculatePlotDetails = (coords) => {
            // simplified port of original logic to keep compatible
            if (coords.length < 2) return { isValid: false };
            const c1 = coords[0]; const c2 = coords[1];
            if (!c1.x || !c2.x) return { isValid: false };
            const width = Math.abs(c1.x - c2.x) + 1;
            const depth = Math.abs(c1.z - c2.z) + 1;
            const blocks = width * depth;
            const base = blocks * 10;
            return { isValid: true, blocks: blocks, baseCost: base, tax: base * 0.1, gst: base * 0.03, cost: base * 1.13 };
        };

    </script>
</body>

</html>