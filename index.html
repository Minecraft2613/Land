<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Land Registry</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div class="container">
        <!-- Login Page -->
        <section id="login-view" class="view-section active">
            <div class="form-container">
                <h2>Minecraft Land Registry</h2>
                <form id="login-form">
                    <div class="form-group">
                        <label for="edition">Minecraft Edition</label>
                        <select id="edition" name="edition">
                            <option value="Java">Java</option>
                            <option value="Bedrock">Bedrock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="name">Minecraft Name</label>
                        <input type="text" id="name" name="name" required>
                    </div>
                    <button type="submit" class="button login-button">Login</button>
                </form>
                <div id="messages" class="messages"></div>
            </div>
        </section>

        <!-- Dashboard Page -->
        <section id="dashboard-view" class="view-section">
            <header class="app-header">
                <h1 id="dashboard-title"></h1>
                <button id="logout-button" class="button logout-button">Logout</button>
            </header>
            <div class="nav-buttons">
                <button id="buy-land-button" class="button">Buy New Land</button>
                <button id="gov-panel-button" class="button" style="display: none;">Government Panel</button>
            </div>
            <h3 style="margin-bottom: 20px;">Your Purchased Lands</h3>
            <div id="user-lands-list" class="card-grid"></div>
            <div id="dashboard-messages" class="messages"></div>
        </section>

        <!-- Buy Land Page -->
        <section id="buy-land-view" class="view-section">
            <header class="app-header">
                <h1>Buy New Land</h1>
                <button id="back-from-buy-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container">
                <form id="buy-land-form">
                    <div class="form-grid">
                        <!-- Coordinates will be generated here -->
                    </div>
                    <div id="live-calculation-card" class="land-card" style="display: none; margin-bottom: 20px;">
                        <h3>Live Calculation</h3>
                        <p>Blocks: <span id="calc-blocks" class="detail-value">0</span></p>
                        <p>Base Cost: $<span id="calc-base-cost" class="detail-value">0.00</span></p>
                        <p>10% Tax: $<span id="calc-tax" class="detail-value">0.00</span></p>
                        <p>3% GST: $<span id="calc-gst" class="detail-value">0.00</span></p>
                        <h4 style="margin-top: 15px;">Total Cost: $<span id="calc-total-cost" class="detail-value">${(0).toFixed(2)}</span></h4>
                    </div>
                    <button type="submit" class="button login-button">Submit & Purchase</button>
                </form>
                <div id="buy-land-messages" class="messages"></div>
                <div id="payment-section" class="land-card" style="display: none; margin-top: 20px;">
                    <h3>Complete Your Purchase In-Game</h3>
                    <div class="gpay-timer-container">
                        <div class="gpay-circle">
                            <span id="countdown">5:00</span>
                        </div>
                    </div>
                    <p>Your land has been reserved. Use the following command in-game:</p>
                    <p><code>/land payment <span id="payment-code"></span> <button id="copy-code-button">Copy</button></code></p>
                    <p>Amount: $<span id="payment-amount"></span></p>
                    <p class="messages message-error" id="payment-warning" style="display: none;">Warning: Payment code will expire soon!</p>
                </div>
            </div>
        </section>

        <!-- Government Panel Page -->
        <section id="gov-panel-view" class="view-section">
            <header class="app-header">
                <h1>Government Panel</h1>
                <button id="back-from-gov-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container" style="max-width: 800px;">
                <div class="card-grid">
                    <div class="land-card">
                        <h3>Government Settings</h3>
                        <form id="gov-settings-form">
                            <div class="form-group">
                                <label for="gov-gap">Government Plot Gap (Blocks)</label>
                                <input type="number" id="gov-gap" name="gov-gap" required>
                            </div>
                            <div class="form-group">
                                <label for="gov-land-type">Type of Land</label>
                                <input type="text" id="gov-land-type" name="gov-land-type" required>
                            </div>
                            <button type="submit" class="button login-button">Save Settings</button>
                        </form>
                    </div>

                    <div class="land-card">
                        <h3>Register Government Land</h3>
                        <form id="register-gov-land-form">
                            <div class="form-group">
                                <label for="gov-land-gap">Gap for Player Lands (Blocks)</label>
                                <input type="number" id="gov-land-gap" name="gov-land-gap" required>
                            </div>
                            <!-- Coords will be generated here -->
                        </form>
                        <button type="submit" class="button login-button" id="register-gov-land-button">Register Land</button>
                    </div>
                </div>
                <div id="gov-panel-messages" class="messages"></div>
                <div class="land-card" style="margin-top: 20px;">
                    <h3>Government Balance</h3>
                    <p>Current Balance: $<span id="gov-balance" class="detail-value">0.00</span></p>
                </div>
                <div class="land-card" style="margin-top: 20px;">
                    <h3>Latest Transactions</h3>
                    <ul id="transaction-list"></ul>
                </div>
            </div>
            
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Player Plot Management</h3>
            <div id="player-management-section">
                <div id="owner-buttons" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;"></div>
                <div id="selected-player-plots" class="card-grid"></div>
            </div>
        </section>
    </div>

    <div id="fullscreen-timer-overlay" style="display: none;">
        <div class="timer-container">
            <div class="outer-ring"></div>
            <div class="inner-ring"></div>
            <div id="fullscreen-countdown">5:00</div>
        </div>
        <div class="payment-details">
            <h3>Complete Your Purchase In-Game</h3>
            <p>Your land has been reserved. Use the following command in-game:</p>
            <p><code>/land payment <span id="fullscreen-payment-code"></span> <button id="fullscreen-copy-code-button">Copy</button></code></p>
            <p>Amount: $<span id="fullscreen-payment-amount"></span></p>
            <button id="cancel-payment-button" class="button">Cancel</button>
        </div>
    </div>

    <div id="payment-loading-overlay" style="display: none;">
        <div class="minecraft-logo"></div>
        <p>Processing Payment...</p>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p id="loading-message">Processing...</p>
    </div>

    <!-- Payment Status Overlay -->
    <div id="payment-status-overlay" style="display: none;">
        <div id="payment-status-icon"></div>
        <p id="payment-status-message"></p>
        <button id="payment-status-close" class="button">Close</button>
    </div>

    <script>
        // Constants
        const MAX_PLAYER_LAND_BLOCKS = 14400;
        const PLAYER_PLOT_GAP = 7;
        const API_URL = 'https://land.1987sakshamsingh.workers.dev';

        // Global state variables
        let currentUser = null;
        let users = [];
        let lands = [];
        let govConfig = { gap: 10, landType: 'Government' };
        let governmentBalance = 0;
        let selectedPlayerForManagement = null;

        // DOM elements
        const views = document.querySelectorAll('.view-section');
        const loginForm = document.getElementById('login-form');
        const logoutButton = document.getElementById('logout-button');
        const dashboardTitle = document.getElementById('dashboard-title');
        const userLandsList = document.getElementById('user-lands-list');
        const buyLandButton = document.getElementById('buy-land-button');
        const govPanelButton = document.getElementById('gov-panel-button');
        const backFromBuyButton = document.getElementById('back-from-buy-button');
        const backFromGovButton = document.getElementById('back-from-gov-button');
        const buyLandForm = document.getElementById('buy-land-form');
        const govSettingsForm = document.getElementById('gov-settings-form');
        const registerGovLandForm = document.getElementById('register-gov-land-form');
        const ownerButtonsContainer = document.getElementById('owner-buttons');
        const selectedPlayerPlotsContainer = document.getElementById('selected-player-plots');
        const buyLandSubmitButton = buyLandForm.querySelector('button[type="submit"]');
        const registerGovLandSubmitButton = document.getElementById('register-gov-land-button');
        
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const paymentStatusOverlay = document.getElementById('payment-status-overlay');
        const paymentStatusIcon = document.getElementById('payment-status-icon');
        const paymentStatusMessage = document.getElementById('payment-status-message');
        const paymentStatusCloseButton = document.getElementById('payment-status-close');

        // Message displays
        const loginMessages = document.getElementById('messages');
        const dashboardMessages = document.getElementById('dashboard-messages');
        const buyLandMessages = document.getElementById('buy-land-messages');
        const govPanelMessages = document.getElementById('gov-panel-messages');

        function showMessage(element, message, type = 'success') {
            element.textContent = message;
            element.className = `messages ${type === 'success' ? 'message-success' : 'message-error'}`;
            if (type === 'success') {
                element.classList.add('animate');
            }
            setTimeout(() => {
                element.textContent = '';
                element.className = 'messages';
            }, 5000);
        }

        function showLoading(message) {
            loadingMessage.textContent = message;
            loadingOverlay.style.display = 'flex';
        }

        function hideLoading() {
            loadingOverlay.style.display = 'none';
        }

        function showPaymentStatus(success, message) {
            paymentStatusOverlay.className = success ? 'success' : 'error';
            paymentStatusIcon.innerHTML = success ? '&#10004;' : '&#10008;'; // Checkmark or X
            paymentStatusMessage.textContent = message;
            paymentStatusOverlay.style.display = 'flex';
        }

        function showPaymentSuccess() {
            const audio = new Audio('https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3'); // A more distinct success sound
            audio.play();
            showPaymentStatus(true, 'Payment Successful!');
        }

        paymentStatusCloseButton.addEventListener('click', () => {
            paymentStatusOverlay.style.display = 'none';
            renderDashboard(); // Go back to dashboard after closing status
        });

        // --- Data Persistence and Loading (Updated to use fetch API) ---
        async function loadData() {
            try {
                const response = await fetch(`${API_URL}/data`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data from API. Status: ${response.status}`);
                }
                const data = await response.json();
                users = data.users || [];
                lands = data.lands || [];
                govConfig = data.govConfig || { gap: 10, landType: 'Government' };
                governmentBalance = data.governmentBalance || 0;

                // Check for pending land claims for the current user
                if (currentUser) {
                    const pendingLand = lands.find(land => 
                        land.owner === currentUser.minecraftName && 
                        !land.paid && 
                        land.paymentCode
                    );
                    if (pendingLand && document.getElementById('fullscreen-timer-overlay').style.display !== 'flex') {
                        document.getElementById('fullscreen-payment-code').textContent = pendingLand.paymentCode;
                        document.getElementById('fullscreen-payment-amount').textContent = pendingLand.cost.toFixed(2);
                        document.getElementById('fullscreen-timer-overlay').style.display = 'flex';
                        startFullscreenCountdown(300, pendingLand.paymentCode); // Assuming 5 minutes duration
                    } else if (!pendingLand && document.getElementById('fullscreen-timer-overlay').style.display === 'flex') {
                        // If no pending land, and overlay is visible, hide it (e.g., if payment was just completed)
                        document.getElementById('fullscreen-timer-overlay').style.display = 'none';
                        document.getElementById('payment-loading-overlay').style.display = 'none';
                        clearInterval(fullscreenCountdownInterval); // Stop the timer if it was running
                    }
                }
            } catch (e) {
                console.error("Could not load data from API", e);
                showMessage(dashboardMessages, 'Failed to load data from the server. Please check the API URL.', 'error');
            }
        }

        async function saveData() {
            try {
                const response = await fetch(`${API_URL}/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ users, lands, govConfig, governmentBalance })
                });
                if (!response.ok) {
                    throw new Error(`Failed to save data to API. Status: ${response.status}`);
                }
                const result = await response.json();
                console.log('Data saved:', result);
                return result; // Return the result on success
            } catch (e) {
                console.error("Could not save data to API", e);
                showMessage(dashboardMessages, 'Failed to save data to the server. Please check the API URL.', 'error');
                throw e; // Re-throw the error so calling functions know it failed
            }
        }

        // --- Utility Functions ---
        const calculatePlotDetails = (coords) => {
            if (coords.length < 2) return { isValid: false };

            const c1 = coords[0];
            const c2 = coords[1];

            const numericC1 = { x: parseFloat(c1.x), y: parseFloat(c1.y), z: parseFloat(c1.z) };
            const numericC2 = { x: parseFloat(c2.x), y: parseFloat(c2.y), z: parseFloat(c2.z) };

            if (isNaN(numericC1.x) || isNaN(numericC1.y) || isNaN(numericC1.z) || isNaN(numericC2.x) || isNaN(numericC2.y) || isNaN(numericC2.z)) {
                return { blocks: 0, cost: 0, baseCost: 0, tax: 0, gst: 0, isValid: false };
            }

            const blockWidth = Math.abs(numericC1.x - numericC2.x) + 1;
            const blockDepth = Math.abs(numericC1.z - numericC2.z) + 1;
            const totalBlocks = blockWidth * blockDepth;

            const baseCost = totalBlocks * 10;
            const tax = baseCost * 0.10;
            const gst = baseCost * 0.03;
            const totalCost = baseCost + tax + gst;
            
            return { blocks: totalBlocks, cost: totalCost, baseCost, tax, gst, isValid: true };
        };

        const isColliding = (newPlotCoords, existingLands, newPlotType, newPlotGap) => {
            const numericNewPlotCoords = newPlotCoords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
            const newMinX = Math.min(numericNewPlotCoords[0].x, numericNewPlotCoords[1].x);
            const newMaxX = Math.max(numericNewPlotCoords[0].x, numericNewPlotCoords[1].x);
            const newMinZ = Math.min(numericNewPlotCoords[0].z, numericNewPlotCoords[1].z);
            const newMaxZ = Math.max(numericNewPlotCoords[0].z, numericNewPlotCoords[1].z);

            for (const existingLand of existingLands) {
                const existingMinX = Math.min(existingLand.coords[0].x, existingLand.coords[1].x);
                const existingMaxX = Math.max(existingLand.coords[0].x, existingLand.coords[1].x);
                const existingMinZ = Math.min(existingLand.coords[0].z, existingLand.coords[1].z);
                const existingMaxZ = Math.max(existingLand.coords[0].z, existingLand.coords[1].z);

                let effectiveNewPlotGap = newPlotGap;
                let effectiveExistingPlotGap = existingLand.gap;

                // Determine effective gap based on plot types
                if (newPlotType === 'Player' && existingLand.landType === 'Player') {
                    // Player vs Player: use PLAYER_PLOT_GAP for both
                    effectiveNewPlotGap = PLAYER_PLOT_GAP;
                    effectiveExistingPlotGap = PLAYER_PLOT_GAP;
                } else if (newPlotType === 'Player' && existingLand.landType !== 'Player') {
                    // Player vs Gov: use PLAYER_PLOT_GAP for player, existingLand.gap for gov
                    effectiveNewPlotGap = PLAYER_PLOT_GAP;
                    effectiveExistingPlotGap = existingLand.gap;
                } else if (newPlotType !== 'Player' && existingLand.landType === 'Player') {
                    // Gov vs Player: use newPlotGap for gov, PLAYER_PLOT_GAP for player
                    effectiveNewPlotGap = newPlotGap;
                    effectiveExistingPlotGap = PLAYER_PLOT_GAP;
                } else if (newPlotType !== 'Player' && existingLand.landType !== 'Player') {
                    // Gov vs Gov: no collision check (effective gap 0)
                    effectiveNewPlotGap = 0;
                    effectiveExistingPlotGap = 0;
                }

                const newPlotWithGapMinX = newMinX - effectiveNewPlotGap;
                const newPlotWithGapMaxX = newMaxX + effectiveNewPlotGap;
                const newPlotWithGapMinZ = newMinZ - effectiveNewPlotGap;
                const newPlotWithGapMaxZ = newMaxZ + effectiveNewPlotGap;

                const existingPlotWithGapMinX = existingMinX - effectiveExistingPlotGap;
                const existingPlotWithGapMaxX = existingMaxX + effectiveExistingPlotGap;
                const existingPlotWithGapMinZ = existingMinZ - effectiveExistingPlotGap;
                const existingPlotWithGapMaxZ = existingMaxZ + effectiveExistingPlotGap;

                // Check for overlap on the X-axis
                const overlapX = Math.max(newPlotWithGapMinX, existingPlotWithGapMinX) < Math.min(newPlotWithGapMaxX, existingPlotWithGapMaxX);
                // Check for overlap on the Z-axis
                const overlapZ = Math.max(newPlotWithGapMinZ, existingPlotWithGapMinZ) < Math.min(newPlotWithGapMaxZ, existingPlotWithGapMaxZ);

                if (overlapX && overlapZ) {
                    // Special rule: Government land can collide with other government land
                    if (newPlotType !== 'Player' && existingLand.landType !== 'Player') {
                        return false; // No collision for Gov vs Gov
                    }
                    showMessage(buyLandMessages, `Collision detected with an existing plot owned by ${existingLand.owner} (${existingLand.landType} land)! Please choose a different location.`, 'error');
                    return true;
                }
            }
            return false;
        };

        let dataPollingInterval;

        function startDataPolling() {
            stopDataPolling(); // Ensure no multiple intervals are running
            dataPollingInterval = setInterval(async () => {
                await loadData();
                if (document.getElementById('dashboard-view').classList.contains('active')) {
                    renderDashboard();
                }
            }, 5000); // Poll every 5 seconds
        }

        function stopDataPolling() {
            clearInterval(dataPollingInterval);
        }

        // --- View Switching ---
        function setView(viewId) {
            views.forEach(view => {
                view.classList.remove('active');
            });
            document.getElementById(viewId).classList.add('active');
        }

        // --- Rendering Functions ---
        function renderDashboard() {
            if (!currentUser) return;
            setView('dashboard-view');
            dashboardTitle.textContent = `Welcome, ${currentUser.minecraftName}!`; // Removed balance display
            
            // Check for government access
            govPanelButton.style.display = currentUser.minecraftName.toLowerCase() === 'minecraft2613' ? 'block' : 'none';

            // Filter lands for the current user and render them
            const userPlots = lands.filter(land => land.owner === currentUser.minecraftName);
            userLandsList.innerHTML = userPlots.map(renderLandCard).join('');

            if (userPlots.length === 0) {
                userLandsList.innerHTML = '<p style="text-align: center; color: var(--text-dark);">You do not own any land yet.</p>';
            }
        }
        
        function renderBuyLand() {
            setView('buy-land-view');
            renderCoordinatesForm(buyLandForm, 2, 'player');
            const coordsInputs = buyLandForm.querySelectorAll('.coord-input');
            const liveCalculationCard = document.getElementById('live-calculation-card');

            // Add event listeners for live calculation
            coordsInputs.forEach(input => {
                input.addEventListener('input', () => {
                    const coords = getFormCoordinates(buyLandForm);
                    const calculatedDetails = calculatePlotDetails(coords);

                    if (calculatedDetails.isValid) {
                        liveCalculationCard.style.display = 'block';
                        document.getElementById('calc-blocks').textContent = calculatedDetails.blocks;
                        document.getElementById('calc-base-cost').textContent = calculatedDetails.baseCost.toFixed(2);
                        document.getElementById('calc-tax').textContent = calculatedDetails.tax.toFixed(2);
                        document.getElementById('calc-gst').textContent = calculatedDetails.gst.toFixed(2);
                        document.getElementById('calc-total-cost').textContent = calculatedDetails.cost.toFixed(2);
                    } else {
                        liveCalculationCard.style.display = 'none';
                    }
                });
            });
        }
        
        function renderGovPanel() {
            setView('gov-panel-view');
            renderCoordinatesForm(registerGovLandForm, 2, 'gov');
            
            // Populate settings form with current values
            document.getElementById('gov-gap').value = govConfig.gap;
            document.getElementById('gov-land-type').value = govConfig.landType;
            document.getElementById('gov-balance').textContent = governmentBalance.toFixed(2);
            
            // Render owner buttons
            const allOwners = [...new Set(lands.map(land => land.owner))];
            ownerButtonsContainer.innerHTML = allOwners.map(owner => `
                <button class="button" data-owner="${owner}">${owner}</button>
            `).join('');

            const paidLands = lands.filter(land => land.paid && land.cost > 0).sort((a, b) => b.purchaseTime - a.purchaseTime).slice(0, 5);
            const transactionList = document.getElementById('transaction-list');
            transactionList.innerHTML = paidLands.map(land => `<li>${land.owner} purchased land for ${land.cost.toFixed(2)}</li>`).join('');

            // Display plots for the currently selected player, or an empty message
            if (selectedPlayerForManagement) {
                displayPlayerPlots(selectedPlayerForManagement);
            } else {
                selectedPlayerPlotsContainer.innerHTML = '<p style="text-align: center; color: var(--text-dark);">Select a player to view their plots.</p>';
            }
        }
        
        function renderLandCard(land) {
            return `
                <div class="land-card">
                    <h3>Plot Owner: ${land.owner}</h3>
                    <p>Blocks: <span class="detail-value">${land.blocks}</span></p>
                    <p>Type: <span class="detail-value">${land.landType}</span></p>
                    <p>Coordinates:</p>
                    <ul>
                        ${land.coords.map(c => `<li>(${c.x}, ${c.y}, ${c.z})</li>`).join('')}
                    </ul>
                    ${land.cost > 0 ? `<p>Cost: $<span class="detail-value">${land.cost.toFixed(2)}</span></p>` : ''}
                    <p>Status: <span class="detail-value">${land.paid ? 'Paid' : 'Pending'}</span></p>
                </div>
            `;
        }
        
        function renderCoordinatesForm(formElement, count, type) {
            const formGrid = formElement.querySelector('.form-grid') || formElement;
            let html = `
                <div class="form-group">
                    <label>Corner 1 (e.g., North-West)</label>
                    <input type="number" name="${type}-coord-x-1" placeholder="X" class="coord-input" required>
                    <input type="number" name="${type}-coord-y-1" placeholder="Y" class="coord-input" required>
                    <input type="number" name="${type}-coord-z-1" placeholder="Z" class="coord-input" required>
                </div>
                <div class="form-group">
                    <label>Corner 2 (e.g., South-East)</label>
                    <input type="number" name="${type}-coord-x-2" placeholder="X" class="coord-input" required>
                    <input type="number" name="${type}-coord-y-2" placeholder="Y" class="coord-input" required>
                    <input type="number" name="${type}-coord-z-2" placeholder="Z" class="coord-input" required>
                </div>
            `;
            formGrid.innerHTML = html;
        }

        function getFormCoordinates(formElement, count = 2, prefix = 'player-coord') {
            const coords = [];
            for (let i = 1; i <= count; i++) {
                const x = formElement.querySelector(`input[name="${prefix}-x-${i}"]`)?.value;
                const y = formElement.querySelector(`input[name="${prefix}-y-${i}"]`)?.value;
                const z = formElement.querySelector(`input[name="${prefix}-z-${i}"]`)?.value;
                coords.push({ x, y, z });
            }
            return coords;
        }

        function displayPlayerPlots(owner) {
            selectedPlayerForManagement = owner;
            const playerPlots = lands.filter(land => land.owner === owner);
            selectedPlayerPlotsContainer.innerHTML = playerPlots.map(renderLandCard).join('');
        }

        // --- Event Listeners ---
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const minecraftName = document.getElementById('name').value.trim();
            const minecraftEdition = document.getElementById('edition').value;
            
            if (!minecraftName) {
                showMessage(loginMessages, 'Please enter a Minecraft name.', 'error');
                return;
            }

            showLoading('Logging in...');
            await loadData(); // Load latest data before login

            let existingUser = users.find(u => u.minecraftName === minecraftName && u.minecraftEdition === minecraftEdition);
            if (existingUser) {
                currentUser = existingUser;
            } else {
                currentUser = { minecraftName, minecraftEdition, wallet: 1000.00 }; // Default starting balance
                users.push(currentUser);
            }

            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            await saveData();
            hideLoading();
            renderDashboard();
            startDataPolling();
        });

        logoutButton.addEventListener('click', () => {
            currentUser = null;
            localStorage.removeItem('currentUser');
            stopDataPolling();
            setView('login-view');
        });

        buyLandButton.addEventListener('click', () => renderBuyLand());
        govPanelButton.addEventListener('click', () => renderGovPanel());
        backFromBuyButton.addEventListener('click', () => renderDashboard());
        backFromGovButton.addEventListener('click', () => renderDashboard());

        buyLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const button = buyLandSubmitButton;
            button.disabled = true;

            try {
                const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
                const calculatedDetails = calculatePlotDetails(coords);

                if (!calculatedDetails.isValid) {
                    showMessage(buyLandMessages, 'Please enter valid numeric coordinates for both points.', 'error');
                    return;
                }

                if (calculatedDetails.blocks > MAX_PLAYER_LAND_BLOCKS) {
                    showMessage(buyLandMessages, `Plot is too large. Max size is ${MAX_PLAYER_LAND_BLOCKS} blocks.`, 'error');
                    return;
                }
                
                const newCoords = coords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
                const isCollision = isColliding(newCoords, lands, 'Player', PLAYER_PLOT_GAP);
                if (isCollision) {
                    hideLoading();
                    return;
                }

                const paymentCode = generatePaymentCode();
                const newLand = {
                    owner: currentUser.minecraftName,
                    coords: newCoords,
                    blocks: calculatedDetails.blocks,
                    cost: calculatedDetails.cost,
                    baseCost: calculatedDetails.baseCost,
                    tax: calculatedDetails.tax,
                    gst: calculatedDetails.gst,
                    gap: PLAYER_PLOT_GAP,
                    landType: 'Player',
                    paymentCode: paymentCode,
                    purchaseTime: new Date().getTime(),
                    paid: false
                };

                lands.push(newLand);
                
                showLoading('Reserving land...');
                await saveData();
                hideLoading();

                // Show fullscreen timer
                document.getElementById('fullscreen-payment-code').textContent = paymentCode;
                document.getElementById('fullscreen-payment-amount').textContent = calculatedDetails.cost.toFixed(2);
                document.getElementById('fullscreen-timer-overlay').style.display = 'flex';

                startFullscreenCountdown(300, paymentCode); // 5 minutes in seconds

            } catch (error) {
                console.error("Buy land submission error:", error);
                hideLoading();
                showPaymentStatus(false, 'An error occurred during reservation.');
            } finally {
                button.disabled = false;
            }
        });

        govSettingsForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newGap = parseInt(document.getElementById('gov-gap').value, 10);
            const newLandType = document.getElementById('gov-land-type').value.trim();

            if (isNaN(newGap) || newGap < 0) {
                showMessage(govPanelMessages, 'Please enter a valid gap.', 'error');
                return;
            }
            if (!newLandType) {
                showMessage(govPanelMessages, 'Please enter a valid land type.', 'error');
                return;
            }

            govConfig.gap = newGap;
            govConfig.landType = newLandType;
            await saveData();
            showMessage(govPanelMessages, 'Government settings updated successfully!', 'success');
            renderGovPanel();
        });

        registerGovLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const button = registerGovLandSubmitButton;
            button.disabled = true;

            try {
                const govCoords = getFormCoordinates(registerGovLandForm, 2, 'gov-coord');
                const calculatedDetails = calculatePlotDetails(govCoords);
                const govLandGap = parseInt(document.getElementById('gov-land-gap').value, 10);

                if (!calculatedDetails.isValid) {
                    showMessage(govPanelMessages, 'Please enter valid numeric coordinates for both points.', 'error');
                    return;
                }

                if (isNaN(govLandGap) || govLandGap < 0) {
                    showMessage(govPanelMessages, 'Please enter a valid gap for player lands.', 'error');
                    return;
                }

                const newCoords = govCoords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
                const isCollision = isColliding(newCoords, lands, govConfig.landType, govConfig.gap);
                if (isCollision) {
                    return;
                }

                const newLand = {
                    owner: currentUser.minecraftName,
                    coords: newCoords,
                    blocks: calculatedDetails.blocks,
                    cost: 0, // Government lands are free
                    gap: govLandGap, // Use the dynamically defined gap
                    landType: govConfig.landType,
                    paymentCode: null, // No payment needed
                    purchaseTime: new Date().getTime(),
                    paid: true // Marked as paid instantly
                };

                lands.push(newLand);
                await saveData();
                showMessage(govPanelMessages, `Successfully registered new government land: ${govConfig.landType}!`, 'success');
                renderGovPanel();
            } catch (error) {
                console.error("Gov land submission error:", error);
                showMessage(govPanelMessages, 'An error occurred while processing your request.', 'error');
            } finally {
                button.disabled = false;
            }
        });

        ownerButtonsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (button && button.dataset.owner) {
                displayPlayerPlots(button.dataset.owner);
            }
        });
        
        function generatePaymentCode() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        let fullscreenCountdownInterval;

        function startFullscreenCountdown(duration, paymentCode) {
            let timer = duration;
            const countdownElement = document.getElementById('fullscreen-countdown');
            const innerRing = document.querySelector('.inner-ring');
            const paymentLoadingOverlay = document.getElementById('payment-loading-overlay');

            clearInterval(fullscreenCountdownInterval);

            // Show the payment loading overlay initially
            paymentLoadingOverlay.style.display = 'flex';
            document.getElementById('loading-message').textContent = 'Waiting for payment confirmation...';

            fullscreenCountdownInterval = setInterval(async () => {
                // Check payment status from the server
                await loadData(); // Reload data to get latest land status
                const currentLand = lands.find(l => l.paymentCode === paymentCode);

                if (currentLand && currentLand.paid) {
                    clearInterval(fullscreenCountdownInterval);
                    paymentLoadingOverlay.style.display = 'none';
                    document.getElementById('fullscreen-timer-overlay').style.display = 'none';
                    showPaymentSuccess();
                    return;
                }

                let minutes = parseInt(timer / 60, 10);
                let seconds = parseInt(timer % 60, 10);

                minutes = minutes < 10 ? "0" + minutes : minutes;
                seconds = seconds < 10 ? "0" + seconds : seconds;

                countdownElement.textContent = minutes + ":" + seconds;

                const percentage = (timer / duration);
                const red = Math.round(255 * (1 - percentage));
                const green = Math.round(255 * percentage);
                innerRing.style.borderColor = `rgb(${red}, ${green}, 0)`;

                if (--timer < 0) {
                    clearInterval(fullscreenCountdownInterval);
                    paymentLoadingOverlay.style.display = 'none';
                    document.getElementById('fullscreen-timer-overlay').style.display = 'none';
                    showPaymentStatus(false, 'Timer is run out! Payment code has expired.');
                }
            }, 1000);

            document.getElementById('fullscreen-copy-code-button').addEventListener('click', () => {
                const paymentCode = document.getElementById('fullscreen-payment-code').textContent;
                navigator.clipboard.writeText(`/land payment ${paymentCode}`).then(() => {
                    alert('Command copied to clipboard!');
                }).catch(err => {
                    console.error('Could not copy text: ', err);
                });
            });

            document.getElementById('cancel-payment-button').onclick = async () => {
                clearInterval(fullscreenCountdownInterval);
                paymentLoadingOverlay.style.display = 'none';
                document.getElementById('fullscreen-timer-overlay').style.display = 'none';
                showLoading('Cancelling payment...');
                try {
                    const response = await fetch(`${API_URL}/cancel-payment`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ paymentCode })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showPaymentStatus(false, 'Payment Cancelled');
                        const audio = new Audio('https://www.soundjay.com/misc/sounds/fail-buzzer-02.mp3'); // A distinct failure sound
                        audio.play();
                    } else {
                        showPaymentStatus(false, 'Failed to cancel payment.');
                    }
                } catch (e) {
                    showPaymentStatus(false, 'Error cancelling payment.');
                }
                hideLoading();
            };
        }

        document.getElementById('copy-code-button').addEventListener('click', () => {
            const paymentCode = document.getElementById('payment-code').textContent;
            navigator.clipboard.writeText(`/land payment ${paymentCode}`).then(() => {
                alert('Command copied to clipboard!');
            }).catch(err => {
                console.error('Could not copy text: ', err);
            });
        });

        document.addEventListener('DOMContentLoaded', async () => {
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                await loadData();
                renderDashboard();
            } else {
                setView('login-view');
            }
        });
    </script>
</body>
</html>