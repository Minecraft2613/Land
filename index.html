<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Land Registry</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
    <script src="noise.js"></script>
</head>

<body>

    <div class="container">
        <!-- Login Page -->
        <section id="login-view" class="view-section active">
            <div class="form-container">
                <h1 style="text-align: center; font-size: 2rem;">Land Registry</h1>
                <p style="text-align: center; color: var(--text-muted); margin-bottom: 2rem;">Secure plots for your
                    server.</p>
                <form id="login-form">
                    <div class="form-group">
                        <label for="edition">Platform Edition</label>
                        <select id="edition" name="edition">
                            <option value="Java">Java Edition</option>
                            <option value="Bedrock">Bedrock Edition</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="name">Gamertag / Username</label>
                        <input type="text" id="name" name="name" placeholder="Stevie123" required>
                    </div>
                    <button type="submit" class="button login-button"
                        style="width: 100%; justify-content: center;">Authenticate</button>
                    <div id="messages" class="messages"></div>
                </form>
            </div>
        </section>

        <!-- Dashboard Page -->
        <section id="dashboard-view" class="view-section">
            <header class="app-header">
                <div>
                    <h1 id="dashboard-title">Dashboard</h1>
                    <p style="color: var(--text-muted);">Manage your real estate.</p>
                </div>
                <div style="display: flex; gap: 1rem;">
                    <button id="buy-land-button" class="button">
                        <span style="font-size: 1.2rem;">+</span> Buy Land
                    </button>
                    <button id="gov-panel-button" class="button"
                        style="display: none; background: linear-gradient(135deg, #f59e0b, #d97706);">Gov Panel</button>
                    <button id="logout-button" class="button logout-button">Log Out</button>
                </div>
            </header>

            <div id="user-lands-list" class="card-grid"></div>
            <div id="dashboard-messages" class="messages"></div>
        </section>

        <!-- Buy Land Page -->
        <section id="buy-land-view" class="view-section">
            <header class="app-header">
                <h1>Purchase Plot</h1>
                <button id="back-from-buy-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container">
                <form id="buy-land-form">
                    <p style="margin-bottom: 1rem; color: var(--text-muted); font-size: 0.9rem;">Enter coordinates for
                        two opposite corners (X, Z). Y is automatically set to 1.</p>
                    <div class="form-grid">
                        <!-- Coordinates will be generated here -->
                    </div>

                    <div id="live-calculation-card"
                        style="display: none; margin-top: 1.5rem; padding: 1rem; background: rgba(0,0,0,0.2); border-radius: 0.5rem;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 0.5rem;">
                            <span style="color: var(--text-muted);">Area</span>
                            <span style="font-weight: 700;"><span id="calc-blocks">0</span> blocks</span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">Base</span>
                            <span>$<span id="calc-base-cost">0.00</span></span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">Tax (10%)</span>
                            <span>$<span id="calc-tax">0.00</span></span>
                        </div>
                        <div
                            style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <span style="color: var(--text-muted);">GST (3%)</span>
                            <span>$<span id="calc-gst">0.00</span></span>
                        </div>
                        <div
                            style="border-top: 1px solid rgba(255,255,255,0.1); margin-top: 0.5rem; padding-top: 0.5rem; display: flex; justify-content: space-between; color: var(--success);">
                            <span style="font-weight: 700;">TOTAL</span>
                            <span style="font-weight: 700; font-size: 1.2rem;">$<span
                                    id="calc-total-cost">0.00</span></span>
                        </div>
                    </div>

                    <button type="submit" class="button login-button"
                        style="width: 100%; justify-content: center; margin-top: 1.5rem;">Confirm Reservation</button>
                    <div id="buy-land-messages" class="messages"></div>
                </form>
            </div>
        </section>

        <!-- Government Panel Page -->
        <section id="gov-panel-view" class="view-section">
            <header class="app-header">
                <h1>Government Admin</h1>
                <button id="back-from-gov-button" class="button logout-button">Back</button>
            </header>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-bottom: 3rem;">
                <div class="land-card">
                    <h3>Global Settings</h3>
                    <form id="gov-settings-form">
                        <div class="form-group">
                            <label for="gov-gap">Plot Buffer (Blocks)</label>
                            <input type="number" id="gov-gap" name="gov-gap" required>
                        </div>
                        <div class="form-group">
                            <label for="gov-land-type">Reserved Land Label</label>
                            <input type="text" id="gov-land-type" name="gov-land-type" required>
                        </div>
                        <button type="submit" class="button">Apply Config</button>
                    </form>
                </div>

                <div class="land-card">
                    <h3>Zone Registration</h3>
                    <form id="register-gov-land-form">
                        <div class="form-group">
                            <label for="gov-land-gap">Player Gap Requirement</label>
                            <input type="number" id="gov-land-gap" name="gov-land-gap" required>
                        </div>
                        <div class="form-grid"></div>
                        <button type="submit" class="button" id="register-gov-land-button"
                            style="margin-top: 1rem;">Register Zone</button>
                    </form>
                </div>
            </div>

            <div id="gov-panel-messages" class="messages"></div>

            <div class="land-card" style="margin-bottom: 2rem;">
                <h3 style="margin-bottom: 1rem;">Treasury</h3>
                <div style="font-size: 2rem; font-weight: 700; color: var(--success);">$<span
                        id="gov-balance">0.00</span></div>
            </div>

            <h3
                style="margin-bottom: 1rem; color: var(--text-muted); text-transform: uppercase; font-size: 0.8rem; letter-spacing: 0.1em;">
                Player Management</h3>
            <div id="player-management-section">
                <div id="owner-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1.5rem;">
                </div>
                <div id="selected-player-plots" class="card-grid"></div>
            </div>
        </section>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p id="loading-message" style="font-weight: 500;">Processing Request...</p>
    </div>

    <!-- Payment Status Overlay (Only for final success/failure result, not pending) -->
    <div id="payment-status-overlay" style="display: none;">
        <div id="payment-status-icon"></div>
        <p id="payment-status-message"></p>
        <button id="payment-status-close" class="button">Close</button>
    </div>

    <script>
        // Constants & Config
        const MAX_PLAYER_LAND_BLOCKS = 144000000000;
        const PLAYER_PLOT_GAP = 7;
        const API_URL = 'https://land.1987sakshamsingh.workers.dev';
        const WORLD_SEED = 67480912992;

        // DOM Elements
        const loginForm = document.getElementById('login-form');
        const loginMessages = document.getElementById('messages');
        const dashboardTitle = document.getElementById('dashboard-title');
        const logoutButton = document.getElementById('logout-button');
        const buyLandButton = document.getElementById('buy-land-button');
        const govPanelButton = document.getElementById('gov-panel-button');
        const userLandsList = document.getElementById('user-lands-list');
        const dashboardMessages = document.getElementById('dashboard-messages');
        const buyLandForm = document.getElementById('buy-land-form');
        const buyLandMessages = document.getElementById('buy-land-messages');
        const backFromBuyButton = document.getElementById('back-from-buy-button');
        const govSettingsForm = document.getElementById('gov-settings-form');
        const registerGovLandForm = document.getElementById('register-gov-land-form');
        const govPanelMessages = document.getElementById('gov-panel-messages');
        const backFromGovButton = document.getElementById('back-from-gov-button');
        const ownerButtonsContainer = document.getElementById('owner-buttons');
        const selectedPlayerPlotsContainer = document.getElementById('selected-player-plots');
        const paymentStatusOverlay = document.getElementById('payment-status-overlay');
        const buyLandSubmitButton = buyLandForm.querySelector('button[type="submit"]');
        const registerGovLandSubmitButton = registerGovLandForm.querySelector('button[type="submit"]');
        const views = document.querySelectorAll('.view-section');

        // State
        let currentUser = null;
        let users = [];
        let lands = [];
        let govConfig = { gap: 10, landType: 'Government' };
        let governmentBalance = 0;
        let selectedPlayerForManagement = null;
        let hasPendingPayment = false;
        let landCardTimers = {};

        // --- Core Functions ---

        async function loadData() {
            try {
                const response = await fetch(`${API_URL}/data`);
                if (!response.ok) throw new Error('API Error');
                const data = await response.json();
                users = data.users || [];
                lands = data.lands || [];
                govConfig = data.govConfig || { gap: 10, landType: 'Government' };
                governmentBalance = data.governmentBalance || 0;
            } catch (e) {
                console.error("Load failed:", e);
            }
        }

        async function saveData() {
            try {
                const response = await fetch(`${API_URL}/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ users, lands, govConfig, governmentBalance })
                });
                return await response.json();
            } catch (e) {
                console.error("Save failed", e);
                throw e;
            }
        }

        // --- Terrain Map System ---

        // Seeded PRNG
        function mulberry32(seed) {
            return function () {
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                var t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) | 0;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        let terrainNoise = null;
        let biomeNoise = null;

        function initNoise() {
            if (!terrainNoise) {
                const rng = mulberry32(WORLD_SEED);
                terrainNoise = new ClassicalNoise(rng);
                const rng2 = mulberry32(WORLD_SEED + 12345);
                biomeNoise = new ClassicalNoise(rng2);
            }
        }

        // Multi-octave FBM for detail
        function fbm(x, z, octaves) {
            let total = 0;
            let amp = 1;
            let freq = 0.003; // Slightly higher frequency for better zoom detail
            let max = 0;
            for (let i = 0; i < octaves; i++) {
                total += terrainNoise.noise(x * freq, 0, z * freq) * amp;
                max += amp;
                amp *= 0.5;
                freq *= 2;
            }
            return (total / max) + 0.5;
        }

        function getNoise(x, z) {
            initNoise();
            // Continentalness (Height)
            const height = fbm(x, z, 5);
            // Moisture / Temperature (Simpler noise)
            const moisture = biomeNoise.noise(x * 0.0015, 0, z * 0.0015) + 0.5;
            return { height, moisture };
        }

        function renderTerrainMap(canvasId, land) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            initNoise();

            // Dynamic Sizing to match container
            const rect = canvas.getBoundingClientRect();
            // Use a higher internal resolution for crispness, then scale down via CSS if needed, 
            // but for performance 1:1 match with displayed size is usually best for this kind of per-pixel op.
            const width = Math.floor(rect.width) || 300;
            const height = Math.floor(rect.height) || 250;
            canvas.width = width;
            canvas.height = height;

            // Map Center
            const c1 = land.coords[0];
            const c2 = land.coords[1];
            const pMinX = Math.min(c1.x, c2.x);
            const pMaxX = Math.max(c1.x, c2.x);
            const pMinZ = Math.min(c1.z, c2.z);
            const pMaxZ = Math.max(c1.z, c2.z);

            const plotW = pMaxX - pMinX;
            const plotD = pMaxZ - pMinZ;
            const plotCenterX = pMinX + (plotW / 2);
            const plotCenterZ = pMinZ + (plotD / 2);

            // View Calculation: "Extend to end of map view" & "same camera position"
            // We want the plot centered. The view scale depends on plot size.
            const maxDim = Math.max(plotW, plotD);
            // Heuristic: Show enough context. Small plots get more context (~100 blocks view).
            // Large plots get proportional context.
            const nominalViewBlocks = Math.max(120, maxDim * 2.0);

            // Aspect Ratio Correction
            // We need mapWorldW / mapWorldH == width / height
            const canvasAspect = width / height;

            let mapWorldW, mapWorldH;
            if (canvasAspect > 1) {
                mapWorldH = nominalViewBlocks;
                mapWorldW = nominalViewBlocks * canvasAspect;
            } else {
                mapWorldW = nominalViewBlocks;
                mapWorldH = nominalViewBlocks / canvasAspect;
            }

            const minX = Math.floor(plotCenterX - mapWorldW / 2);
            const minZ = Math.floor(plotCenterZ - mapWorldH / 2);

            // Terrain Render
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const blocksPerPixel = mapWorldW / width; // roughly same for Z

            for (let py = 0; py < height; py++) {
                // Optimization: Pre-calc Z world coord
                const wz = minZ + (py * blocksPerPixel);
                for (let px = 0; px < width; px++) {
                    const wx = minX + (px * blocksPerPixel);

                    const { height: h, moisture: m } = getNoise(wx, wz);

                    let r, g, b;

                    // Enhanced Biome Palette
                    if (h < 0.44) { // Deep Ocean
                        r = 30; g = 60; b = 160;
                    } else if (h < 0.49) { // Ocean
                        r = 60; g = 110; b = 210;
                    } else if (h < 0.51) { // Beach
                        r = 238; g = 214; b = 175;
                    } else {
                        // Land
                        if (h > 0.88) { // Snow Peak
                            r = 245; g = 245; b = 255;
                        } else if (h > 0.72) { // Mountains / Stone
                            if (m < 0.3) { r = 130; g = 120; b = 110; } // Dry
                            else { r = 110; g = 110; b = 110; }
                        } else {
                            // Vegetation
                            if (m < 0.25) { // Desert
                                r = 220; g = 190; b = 110;
                            } else if (m < 0.45) { // Plains / Savanna
                                r = 140; g = 185; b = 75;
                            } else if (m < 0.75) { // Forest
                                r = 60; g = 150; b = 60;
                            } else { // Jungle / Swamp
                                r = 40; g = 115; b = 50;
                            }
                        }
                    }

                    // 3D Hillshading effect
                    // Standard technique: derivative of noise
                    // Sample slightly offset point for slope approximation
                    // Since specific pixel derivative is expensive, we use a cheap analytical trick 
                    // or just sample one neighbor since we are low-res relatively.

                    // Note: Calling getNoise again per pixel is heavy, so we fallback to a faster local estimation 
                    // or just reuse the noise generated. But independent hillshade noise looks better for texture.

                    // Let's use a separate high-freq noise for surface texture/bumpiness
                    const slopeVal = terrainNoise.noise(wx * 0.01, 0, wz * 0.01);
                    const slopeX = (terrainNoise.noise((wx + 1) * 0.005, 0, wz * 0.005) - terrainNoise.noise(wx * 0.005, 0, wz * 0.005)) * 40;
                    const slopeZ = (terrainNoise.noise(wx * 0.005, 0, (wz + 1) * 0.005) - terrainNoise.noise(wx * 0.005, 0, wz * 0.005)) * 40;

                    // Light coming from North-West
                    const light = (slopeX - slopeZ) + (h * 5); // Add height bias
                    const shade = Math.max(-30, Math.min(30, light * 5));

                    r = Math.max(0, Math.min(255, r + shade));
                    g = Math.max(0, Math.min(255, g + shade));
                    b = Math.max(0, Math.min(255, b + shade));

                    const idx = (py * width + px) * 4;
                    data[idx] = r;
                    data[idx + 1] = g;
                    data[idx + 2] = b;
                    data[idx + 3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);

            // --- Overlays (Boundaries) ---
            const worldToScreen = (wx, wz) => ({
                x: (wx - minX) / blocksPerPixel,
                y: (wz - minZ) / blocksPerPixel
            });

            lands.forEach(l => {
                const lMinX = Math.min(l.coords[0].x, l.coords[1].x);
                const lMaxX = Math.max(l.coords[0].x, l.coords[1].x);
                const lMinZ = Math.min(l.coords[0].z, l.coords[1].z);
                const lMaxZ = Math.max(l.coords[0].z, l.coords[1].z);

                // Culling: Check if land overlaps with current map view
                // Map view is [minX, minX + mapWorldW] x [minZ, minZ + mapWorldH]
                if (lMaxX < minX || lMinX > minX + mapWorldW || lMaxZ < minZ || lMinZ > minZ + mapWorldH) return;

                const isMyLand = (l.owner === currentUser.minecraftName);
                const isCurrentPlot = (l === land); // The specific card we are rendering

                // User Request: "show others land will be shown in red... my owned land with dark green"
                // "dont show full land boundry of other but show when the other land is just beside me"
                // My interpretation: Always show boundaries if they are in view.

                let strokeColor, fillColor, lineW;

                if (isMyLand) {
                    strokeColor = '#166534'; // Dark Green
                    fillColor = 'rgba(22, 101, 52, 0.2)';
                    lineW = 2;
                } else {
                    strokeColor = '#dc2626'; // Red
                    fillColor = 'rgba(220, 38, 38, 0.15)';
                    lineW = 1;
                }

                if (isCurrentPlot) {
                    strokeColor = '#4ade80'; // Brighter green for active focus
                    lineW = 3;
                    fillColor = 'rgba(74, 222, 128, 0.05)'; // Clearer inside
                }

                const p1 = worldToScreen(lMinX, lMinZ);
                const p2 = worldToScreen(lMaxX, lMaxZ);

                // Canvas coords
                const x = p1.x;
                const y = p1.y;
                const w = Math.max(1, p2.x - p1.x);
                const h = Math.max(1, p2.y - p1.y);

                ctx.fillStyle = fillColor;
                ctx.fillRect(x, y, w, h);

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = lineW;
                ctx.strokeRect(x, y, w, h);

                // Optional: Label
                if (w > 30 && h > 15) {
                    ctx.fillStyle = 'rgba(255,255,255,0.9)';
                    ctx.font = isCurrentPlot ? 'bold 12px Inter' : '10px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const name = l.owner.length > 8 ? l.owner.substring(0, 6) + '..' : l.owner;
                    ctx.fillText(name, x + w / 2, y + h / 2);
                }
            });

            // Scale Bar
            const barWidthBlocks = Math.pow(10, Math.floor(Math.log10(mapWorldW * 0.25)));
            const barPixelWidth = barWidthBlocks / blocksPerPixel;

            if (barPixelWidth > 20) {
                ctx.shadowColor = 'rgba(0,0,0,0.8)';
                ctx.shadowBlur = 4;
                ctx.fillStyle = 'white';
                ctx.fillRect(15, height - 15, barPixelWidth, 4);
                ctx.fillRect(15, height - 20, 1, 9); // left tick
                ctx.fillRect(15 + barPixelWidth, height - 20, 1, 9); // right tick

                ctx.font = '11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`${barWidthBlocks} m`, 20 + barPixelWidth, height - 12);
                ctx.shadowBlur = 0;
            }
        }


        // --- UI Rendering ---

        function renderLandCard(land) {
            const isPending = !land.paid && land.paymentCode && (new Date().getTime() < land.expirationTime);
            const statusClass = land.paid ? 'status-paid' : (isPending ? 'status-pending' : 'status-expired');
            const statusText = land.paid ? 'OWNED' : (isPending ? 'RESERVED' : 'EXPIRED');
            const canvasId = `map-${land.id || land.paymentCode}`;

            const c1 = land.coords[0];
            const c2 = land.coords[1];

            return `
                <div class="land-card">
                    <canvas id="${canvasId}" class="land-map-canvas"></canvas>
                    
                    <div class="land-details">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 0.5rem;">
                            <h3>${land.landType} Plot</h3>
                            <span class="detail-value ${statusClass}" style="padding: 0.2rem 0.6rem; border-radius: 6px; background: rgba(0,0,0,0.4); font-size:0.75rem; letter-spacing:0.05em;">${statusText}</span>
                        </div>
                        
                        <div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin-bottom: 0.5rem; font-size: 0.85rem;">
                            <div style="background:rgba(255,255,255,0.05); padding:0.5rem; border-radius:4px;">
                                <span style="color:var(--text-muted); display:block; font-size:0.7rem;">X Range</span>
                                <span class="detail-value">${Math.min(c1.x, c2.x)} ↔ ${Math.max(c1.x, c2.x)}</span>
                            </div>
                             <div style="background:rgba(255,255,255,0.05); padding:0.5rem; border-radius:4px;">
                                <span style="color:var(--text-muted); display:block; font-size:0.7rem;">Z Range</span>
                                <span class="detail-value">${Math.min(c1.z, c2.z)} ↔ ${Math.max(c1.z, c2.z)}</span>
                            </div>
                        </div>
                        <p style="text-align:right; font-size:0.8rem; color:var(--text-muted);">Area: <span style="color:var(--text-main);">${land.blocks.toLocaleString()} m²</span></p>
                    </div>

                    ${isPending ? `
                        <div class="pending-payment-section" id="pending-section-${land.paymentCode}">
                            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                                <h4 style="margin:0;">Payment Required</h4>
                                <span id="timer-${land.paymentCode}" class="timer-display" style="background:rgba(0,0,0,0.3); padding:0.1rem 0.4rem; border-radius:4px;">--:--</span>
                            </div>
                            
                            <div style="display:flex; gap:0.5rem; margin-bottom:0.5rem;">
                                <code style="flex-grow:1; text-align:center; padding:0.5rem; border:1px dashed var(--warning); background:rgba(245, 158, 11, 0.05); display:flex; align-items:center; justify-content:center;">/land payment ${land.paymentCode}</code>
                                <button class="button copy-button" onclick="copyCommand('${land.paymentCode}', this)" style="background:var(--bg-card); border-color:var(--glass-border); min-width:80px;">
                                    <svg xmlns="http://www.w3.org/2001/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                                    Copy
                                </button>
                            </div>
                            
                            <button class="button cancel-button" style="width:100%; justify-content:center; margin-top:0.5rem;" onclick="cancelPayment('${land.paymentCode}')">Cancel Reservation</button>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderDashboard() {
            if (!currentUser) return;
            setView('dashboard-view');

            dashboardTitle.textContent = `Welcome, ${currentUser.minecraftName}`;
            govPanelButton.style.display = currentUser.minecraftName.toLowerCase() === 'minecraft2613' ? 'flex' : 'none';

            // Check pending payments globally to disable button
            hasPendingPayment = lands.some(l => !l.paid && l.owner === currentUser.minecraftName && new Date().getTime() < l.expirationTime);

            buyLandButton.disabled = hasPendingPayment;
            buyLandButton.style.opacity = hasPendingPayment ? '0.5' : '1';
            buyLandButton.innerHTML = hasPendingPayment ? '<span style="font-size:1.2rem; margin-right:0.5rem;">⏳</span> One Reservation Active' : '<span style="font-size:1.2rem; margin-right:0.5rem;">+</span> Buy Land';

            // Render Cards
            const myLands = lands.filter(l => l.owner === currentUser.minecraftName);
            userLandsList.innerHTML = myLands.length ? myLands.map(renderLandCard).join('') : '<p style="grid-column: 1/-1; text-align: center; color: var(--text-muted);">You own no land. Start your empire today!</p>';

            // Post-render: Initialize Maps and Timers
            myLands.forEach(land => {
                // Render Map
                renderTerrainMap(`map-${land.id || land.paymentCode}`, land);

                // Initialize Timer if pending
                if (!land.paid && land.paymentCode && new Date().getTime() < land.expirationTime) {
                    startCardTimer(land.paymentCode, land.expirationTime);
                }
            });
        }

        // --- Logic & Timers ---

        function startCardTimer(code, expiry) {
            if (landCardTimers[code]) clearInterval(landCardTimers[code]);

            const tick = () => {
                const now = new Date().getTime();
                const left = Math.ceil((expiry - now) / 1000);
                const el = document.getElementById(`timer-${code}`);

                if (!el) { clearInterval(landCardTimers[code]); return; }

                if (left <= 0) {
                    el.textContent = "Expired";
                    clearInterval(landCardTimers[code]);
                    // Auto-refresh to show expired state
                    loadData().then(renderDashboard);
                } else {
                    const m = Math.floor(left / 60).toString().padStart(2, '0');
                    const s = (left % 60).toString().padStart(2, '0');
                    el.textContent = `${m}:${s}`;
                }
            };

            tick();
            landCardTimers[code] = setInterval(tick, 1000);

            // Poll for payment success specifically for this card
            const poller = setInterval(async () => {
                await loadData();
                const l = lands.find(x => x.paymentCode === code);
                if (!l || l.paid) {
                    clearInterval(poller);
                    clearInterval(landCardTimers[code]);
                    if (l && l.paid) showPaymentSuccess();
                    renderDashboard();
                }
            }, 3000);
        }

        async function cancelPayment(code) {
            if (!confirm("Cancel this reservation?")) return;
            showLoading("Cancelling...");
            try {
                await fetch(`${API_URL}/cancel-payment`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ paymentCode: code })
                });
                await loadData();
                renderDashboard();
            } catch (e) { console.error(e); }
            hideLoading();
        }

        // --- Form Handling ---

        function copyCommand(code, btn) {
            const cmd = `/land payment ${code}`;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(cmd).then(() => {
                    const originalText = btn.innerHTML;
                    btn.innerHTML = `<span style="color:#6ee7b7; font-weight:bold;">✓ Copied</span>`;
                    btn.style.borderColor = '#10b981';
                    setTimeout(() => {
                        btn.innerHTML = originalText;
                        btn.style.borderColor = '';
                    }, 2000);
                });
            } else {
                // Fallback
                prompt("Copy this:", cmd);
            }
        }

        function renderBuyLand() {
            setView('buy-land-view');
            renderCoordinatesForm(buyLandForm, 2, 'player');
            // Re-attach live calc listeners which are lost on innerHTML replace
            const inputs = buyLandForm.querySelectorAll('input');
            inputs.forEach(i => i.addEventListener('input', updateLiveCalc));
        }

        function updateLiveCalc() {
            const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
            const details = calculatePlotDetails(coords);
            const card = document.getElementById('live-calculation-card');

            if (details.isValid) {
                card.style.display = 'block';
                document.getElementById('calc-blocks').textContent = details.blocks.toLocaleString();
                document.getElementById('calc-base-cost').textContent = details.baseCost.toFixed(2);
                document.getElementById('calc-tax').textContent = details.tax.toFixed(2);
                document.getElementById('calc-gst').textContent = details.gst.toFixed(2);
                document.getElementById('calc-total-cost').textContent = details.cost.toFixed(2);
            } else {
                card.style.display = 'none';
            }
        }

        // Helpers
        function renderCoordinatesForm(el, count, type) {
            let html = '';
            for (let i = 1; i <= count; i++) {
                html += `<div class="form-group"><label>Point ${i}</label><div style="display:grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                 <input type="number" name="${type}-coord-x-${i}" placeholder="X" required class="coord-input">
                 <!-- Y hidden -->
                 <input type="hidden" name="${type}-coord-y-${i}" value="1">
                 <input type="number" name="${type}-coord-z-${i}" placeholder="Z" required class="coord-input">
                 </div></div>`;
            }
            el.querySelector('.form-grid').innerHTML = html;
        }
        function getFormCoordinates(el, count, prefix) {
            const arr = [];
            for (let i = 1; i <= count; i++) {
                const x = el.querySelector(`[name="${prefix}-x-${i}"]`).value;
                const y = el.querySelector(`[name="${prefix}-y-${i}"]`).value || 1;
                const z = el.querySelector(`[name="${prefix}-z-${i}"]`).value;
                arr.push({ x, y, z });
            }
            return arr;
        }

        // --- Standard Utils ---

        function setView(id) {
            views.forEach(v => v.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function showLoading(msg) {
            document.getElementById('loading-message').textContent = msg;
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }
        function showMessage(el, msg, type) {
            if (!el) return;
            el.textContent = msg;
            el.className = `messages message-${type}`;
            el.style.display = 'block';
            setTimeout(() => { el.style.display = 'none'; }, 4000);
        }
        function showPaymentSuccess() {
            const overlay = document.getElementById('payment-status-overlay');
            if (overlay) {
                // Minimal success interaction
                const audio = new Audio('https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3');
                audio.play().catch(e => { }); // ignore autoplay policy
                document.getElementById('payment-status-message').textContent = "Payment Successful!";
                document.getElementById('payment-status-icon').innerHTML = '<svg xmlns="http://www.w3.org/2001/svg" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="2" width="64" height="64"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>';
                overlay.style.display = 'flex';
            }
        }

        // --- Init ---

        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = document.getElementById('name').value.trim();
            if (!name) return;

            showLoading("Authenticating...");
            await loadData();

            let user = users.find(u => u.minecraftName === name);
            if (!user) {
                user = { minecraftName: name, minecraftEdition: document.getElementById('edition').value };
                users.push(user);
                await saveData();
            }
            currentUser = user;
            hideLoading();
            renderDashboard();
        });

        // Event Listeners for Buttons
        document.getElementById('logout-button').addEventListener('click', () => { window.location.reload(); });
        document.getElementById('payment-status-close').addEventListener('click', () => { document.getElementById('payment-status-overlay').style.display = 'none'; });
        buyLandButton.addEventListener('click', renderBuyLand);
        document.getElementById('back-from-buy-button').addEventListener('click', () => setView('dashboard-view'));

        // Buy Land Submit
        buyLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            showLoading("Reserving Plot...");
            try {
                const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
                const details = calculatePlotDetails(coords); // reuse existing logic

                // Construct payload manually since verify logic is client-side here
                // Note: Production should verify server-side
                const payload = {
                    owner: currentUser.minecraftName,
                    coords: coords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) })),
                    blocks: details.blocks,
                    cost: details.cost,
                    baseCost: details.baseCost,
                    tax: details.tax,
                    gst: details.gst,
                    gap: PLAYER_PLOT_GAP,
                    landType: 'Player'
                };

                const res = await fetch(`${API_URL}/reserve-land-web`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const json = await res.json();

                if (json.success) {
                    await loadData();
                    renderDashboard();
                } else {
                    alert("Error: " + json.message);
                }
            } catch (err) {
                console.error(err);
                alert("Reservation Failed");
            }
            hideLoading();
        });

        // Init
        loadData();

        // Helpers I preserved from original code for math
        const calculatePlotDetails = (coords) => {
            // simplified port of original logic to keep compatible
            if (coords.length < 2) return { isValid: false };
            const c1 = coords[0]; const c2 = coords[1];
            if (!c1.x || !c2.x) return { isValid: false };
            const width = Math.abs(c1.x - c2.x) + 1;
            const depth = Math.abs(c1.z - c2.z) + 1;
            const blocks = width * depth;
            const base = blocks * 10;
            return { isValid: true, blocks: blocks, baseCost: base, tax: base * 0.1, gst: base * 0.03, cost: base * 1.13 };
        };

    </script>
</body>

</html>