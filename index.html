<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Land Registry</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="style.css">
    <script src="noise.js"></script>
</head>
<body>

    <div class="container">
        <!-- Login Page -->
        <section id="login-view" class="view-section active">
            <div class="form-container">
                <h2>Minecraft Land Registry</h2>
                <form id="login-form">
                    <div class="form-group">
                        <label for="edition">Minecraft Edition</label>
                        <select id="edition" name="edition">
                            <option value="Java">Java</option>
                            <option value="Bedrock">Bedrock</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="name">Minecraft Name</label>
                        <input type="text" id="name" name="name" required>
                    </div>
                    <button type="submit" class="button login-button">Login</button>
                </form>
                <div id="messages" class="messages"></div>
            </div>
        </section>

        <!-- Dashboard Page -->
        <section id="dashboard-view" class="view-section">
            <header class="app-header">
                <h1 id="dashboard-title"></h1>
                <button id="logout-button" class="button logout-button">Logout</button>
            </header>
            <div class="nav-buttons">
                <button id="buy-land-button" class="button">Buy New Land</button>
                <button id="gov-panel-button" class="button" style="display: none;">Government Panel</button>
            </div>
            <h3 style="margin-bottom: 20px;">Your Purchased Lands</h3>
            <div id="user-lands-list" class="card-grid"></div>
            <div id="dashboard-messages" class="messages"></div>
        </section>

        <!-- Buy Land Page -->
        <section id="buy-land-view" class="view-section">
            <header class="app-header">
                <h1>Buy New Land</h1>
                <button id="back-from-buy-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container">
                <form id="buy-land-form">
                    <div class="form-grid">
                        <!-- Coordinates will be generated here -->
                    </div>
                    <div id="live-calculation-card" class="land-card" style="display: none; margin-bottom: 20px;">
                        <h3>Live Calculation</h3>
                        <p>Blocks: <span id="calc-blocks" class="detail-value">0</span></p>
                        <p>Base Cost: $<span id="calc-base-cost" class="detail-value">0.00</span></p>
                        <p>10% Tax: $<span id="calc-tax" class="detail-value">0.00</span></p>
                        <p>3% GST: $<span id="calc-gst" class="detail-value">0.00</span></p>
                        <h4 style="margin-top: 15px;">Total Cost: $<span id="calc-total-cost" class="detail-value">${(0).toFixed(2)}</span></h4>
                    </div>
                    <button type="submit" class="button login-button">Submit & Purchase</button>
                </form>
                <div id="buy-land-messages" class="messages"></div>
            </div>
        </section>

        <!-- Government Panel Page -->
        <section id="gov-panel-view" class="view-section">
            <header class="app-header">
                <h1>Government Panel</h1>
                <button id="back-from-gov-button" class="button logout-button">Back</button>
            </header>
            <div class="form-container" style="max-width: 800px;">
                <div class="card-grid">
                    <div class="land-card">
                        <h3>Government Settings</h3>
                        <form id="gov-settings-form">
                            <div class="form-group">
                                <label for="gov-gap">Government Plot Gap (Blocks)</label>
                                <input type="number" id="gov-gap" name="gov-gap" required>
                            </div>
                            <div class="form-group">
                                <label for="gov-land-type">Type of Land</label>
                                <input type="text" id="gov-land-type" name="gov-land-type" required>
                            </div>
                            <button type="submit" class="button login-button">Save Settings</button>
                        </form>
                    </div>

                    <div class="land-card">
                        <h3>Register Government Land</h3>
                        <form id="register-gov-land-form">
                            <div class="form-group">
                                <label for="gov-land-gap">Gap for Player Lands (Blocks)</label>
                                <input type="number" id="gov-land-gap" name="gov-land-gap" required>
                            </div>
                            <!-- Coords will be generated here -->
                        </form>
                        <button type="submit" class="button login-button" id="register-gov-land-button">Register Land</button>
                    </div>
                </div>
                <div id="gov-panel-messages" class="messages"></div>
                <div class="land-card" style="margin-top: 20px;">
                    <h3>Government Balance</h3>
                    <p>Current Balance: $<span id="gov-balance" class="detail-value">0.00</span></p>
                </div>
                <div class="land-card" style="margin-top: 20px;">
                    <h3>Latest Transactions</h3>
                    <ul id="transaction-list"></ul>
                </div>
            </div>
            
            <h3 style="margin-top: 30px; margin-bottom: 20px;">Player Plot Management</h3>
            <div id="player-management-section">
                <div id="owner-buttons" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;"></div>
                <div id="selected-player-plots" class="card-grid"></div>
            </div>
        </section>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
        <p id="loading-message">Processing...</p>
    </div>

    <!-- Payment Status Overlay -->
    <div id="payment-status-overlay" style="display: none;">
        <div id="payment-status-icon"></div>
        <p id="payment-status-message"></p>
        <button id="payment-status-close" class="button">Close</button>
    </div>

    <script>
        // Constants
        const MAX_PLAYER_LAND_BLOCKS = 144000000000;
        const PLAYER_PLOT_GAP = 7;
        const API_URL = 'https://land.1987sakshamsingh.workers.dev';

        // Global state variables
        let currentUser = null;
        let users = [];
        let lands = [];
        let govConfig = { gap: 10, landType: 'Government' };
        let governmentBalance = 0;
        let selectedPlayerForManagement = null;
        let paymentSuccessHandled = false;
        let hasPendingPayment = false; // New global state

        function showPaymentSuccess() {
            const audio = new Audio('https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3'); // A more distinct success sound
            audio.play();
            showPaymentStatus(true, 'Payment Successful!');
        }

        paymentStatusCloseButton.addEventListener('click', () => {
            paymentStatusOverlay.style.display = 'none';
            paymentStatusOverlay.innerHTML = `
                <div id="payment-status-icon"></div>
                <p id="payment-status-message"></p>
                <button id="payment-status-close" class="button">Close</button>
            `;
            if (currentUser) { // Only render dashboard if a user is logged in
                renderDashboard();
            } else {
                setView('login-view'); // Go back to login if no user
            }
        });

        // --- Data Persistence and Loading (Updated to use fetch API) ---
        async function loadData() {
            try {
                const response = await fetch(`${API_URL}/data`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch data from API. Status: ${response.status}`);
                }
                const data = await response.json();
                users = data.users || [];
                lands = data.lands || [];
                govConfig = data.govConfig || { gap: 10, landType: 'Government' };
                governmentBalance = data.governmentBalance || 0;

                // Check for pending land claims for the current user
                hasPendingPayment = false; // Reset flag
                if (currentUser) {
                    const pendingLand = lands.find(land =>
                        land.owner === currentUser.minecraftName &&
                        !land.paid &&
                        land.paymentCode &&
                        new Date().getTime() < land.expirationTime // Only consider not-expired pending payments
                    );

                    if (pendingLand) {
                        hasPendingPayment = true; // Set flag if there's an active pending payment
                    }
                }
            } catch (e) {
                showMessage(dashboardMessages, 'Failed to load data from the server.', 'error');
            }
        }

        async function saveData() {
            try {
                const response = await fetch(`${API_URL}/data`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ users, lands, govConfig, governmentBalance })
                });
                if (!response.ok) {
                    throw new Error(`Failed to save data to API. Status: ${response.status}`);
                }
                const result = await response.json();
                return result; // Return the result on success
            } catch (e) {
                showMessage(dashboardMessages, 'Failed to save data to the server.', 'error');
                throw e; // Re-throw the error so calling functions know it failed
            }
        }

        // --- Utility Functions ---
        const calculatePlotDetails = (coords) => {
            if (coords.length < 2) return { isValid: false };

            const c1 = coords[0];
            const c2 = coords[1];

            const numericC1 = { x: parseFloat(c1.x), y: parseFloat(c1.y), z: parseFloat(c1.z) };
            const numericC2 = { x: parseFloat(c2.x), y: parseFloat(c2.y), z: parseFloat(c2.z) };

            if (isNaN(numericC1.x) || isNaN(numericC1.y) || isNaN(numericC1.z) || isNaN(numericC2.x) || isNaN(numericC2.y) || isNaN(numericC2.z)) {
                return { blocks: 0, cost: 0, baseCost: 0, tax: 0, gst: 0, isValid: false };
            }

            const blockWidth = Math.abs(numericC1.x - numericC2.x) + 1;
            const blockDepth = Math.abs(numericC1.z - numericC2.z) + 1;
            const totalBlocks = blockWidth * blockDepth;

            const baseCost = totalBlocks * 10;
            const tax = baseCost * 0.10;
            const gst = baseCost * 0.03;
            const totalCost = baseCost + tax + gst;
            
            return { blocks: totalBlocks, cost: totalCost, baseCost, tax, gst, isValid: true };
        };

        const isColliding = (newPlotCoords, existingLands, newPlotType, newPlotGap) => {
            const numericNewPlotCoords = newPlotCoords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
            const newMinX = Math.min(numericNewPlotCoords[0].x, numericNewPlotCoords[1].x);
            const newMaxX = Math.max(numericNewPlotCoords[0].x, numericNewPlotCoords[1].x);
            const newMinZ = Math.min(numericNewPlotCoords[0].z, numericNewPlotCoords[1].z);
            const newMaxZ = Math.max(numericNewPlotCoords[0].z, numericNewPlotCoords[1].z);

            for (const existingLand of existingLands) {
                const numericExistingLandCoords = existingLand.coords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
                const existingMinX = Math.min(numericExistingLandCoords[0].x, numericExistingLandCoords[1].x);
                const existingMaxX = Math.max(numericExistingLandCoords[0].x, numericExistingLandCoords[1].x);
                const existingMinZ = Math.min(numericExistingLandCoords[0].z, numericExistingLandCoords[1].z);
                const existingMaxZ = Math.max(numericExistingLandCoords[0].z, numericExistingLandCoords[1].z);

                let effectiveNewPlotGap = newPlotGap;
                let effectiveExistingPlotGap = existingLand.gap;

                // Determine effective gap based on plot types
                if (newPlotType === 'Player') {
                    effectiveNewPlotGap = 0; // No gap for new player plots
                }
                if (existingLand.landType === 'Player') {
                    effectiveExistingPlotGap = 0; // No gap for existing player plots
                } else if (newPlotType === 'Player' && existingLand.landType !== 'Player') {
                    // Player vs Gov: use 0 for player, existingLand.gap for gov
                    effectiveNewPlotGap = 0;
                    effectiveExistingPlotGap = existingLand.gap;
                } else if (newPlotType !== 'Player' && existingLand.landType === 'Player') {
                    // Gov vs Player: use newPlotGap for gov, 0 for player
                    effectiveNewPlotGap = newPlotGap;
                    effectiveExistingPlotGap = 0;
                } else if (newPlotType !== 'Player' && existingLand.landType !== 'Player') {
                    // Gov vs Gov: no collision check (effective gap 0)
                    effectiveNewPlotGap = 0;
                    effectiveExistingPlotGap = 0;
                }

                const newPlotWithGapMinX = newMinX - effectiveNewPlotGap;
                const newPlotWithGapMaxX = newMaxX + effectiveNewPlotGap;
                const newPlotWithGapMinZ = newMinZ - effectiveNewPlotGap;
                const newPlotWithGapMaxZ = newMaxZ + effectiveNewPlotGap;

                const existingPlotWithGapMinX = existingMinX - effectiveExistingPlotGap;
                const existingPlotWithGapMaxX = existingMaxX + effectiveExistingPlotGap;
                const existingPlotWithGapMinZ = existingMinZ - effectiveExistingPlotGap;
                const existingPlotWithGapMaxZ = existingMaxZ + effectiveExistingPlotGap;

                // Check for overlap on the X-axis
                const overlapX = Math.max(newPlotWithGapMinX, existingPlotWithGapMinX) < Math.min(newPlotWithGapMaxX, existingPlotWithGapMaxX);
                // Check for overlap on the Z-axis
                const overlapZ = Math.max(newPlotWithGapMinZ, existingPlotWithGapMinZ) < Math.min(newPlotWithGapMaxZ, existingPlotWithGapMaxZ);

                if (overlapX && overlapZ) {
                    // Special rule: Government land can collide with other government land
                    if (newPlotType !== 'Player' && existingLand.landType !== 'Player') {
                        return false; // No collision for Gov vs Gov
                    }
                    showMessage(buyLandMessages, `Collision detected with an existing plot owned by ${existingLand.owner} (${existingLand.landType} land)! Please choose a different location.`, 'error');
                    return true;
                }
            }
            return false;
        };

        const WORLD_SEED = 67480912992; // The world seed provided by the user
        const ISO_ANGLE_X = Math.PI / 6; // Isometric angle in radians (30 degrees)
        const ISO_ANGLE_Y = Math.PI / 6; // Isometric angle in radians (30 degrees)

        // Function to create a seeded random number generator
        function mulberry32(seed) {
            return function() {
                seed |= 0; seed = seed + 0x6D2B79F5 | 0;
                var t = Math.imul(seed ^ seed >>> 15, 1 | seed);
                t = t + Math.imul(t ^ t >>> 7, 61 | t) | 0;
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        // Initialize noise generator with the world seed
        let seededNoise = null;
        function getSeededNoise(x, y, scale = 0.05, octaves = 4, persistence = 0.5, lacunarity = 2.0) {
            if (!seededNoise) {
                const rng = mulberry32(WORLD_SEED);
                seededNoise = new ClassicalNoise(rng);
            }

            let total = 0;
            let frequency = 1;
            let amplitude = 1;
            let maxValue = 0; // Used for normalizing result to 0.0 - 1.0

            for (let i = 0; i < octaves; i++) {
                total += seededNoise.noise(x * scale * frequency, y * scale * frequency, 0) * amplitude;
                maxValue += amplitude;
                amplitude *= persistence;
                frequency *= lacunarity;
            }

            return total / maxValue; // Normalized value
        }


        function renderTerrainMap(canvasId, land, width = 200, height = 150) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const coords = land.coords;

            canvas.width = width;
            canvas.height = height;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate min/max X and Z coordinates for the plot
            const minX = Math.min(coords[0].x, coords[1].x);
            const maxX = Math.max(coords[0].x, coords[1].x);
            const minZ = Math.min(coords[0].z, coords[1].z);
            const maxZ = Math.max(coords[0].z, coords[1].z);

            const plotWidth = maxX - minX + 1;
            const plotDepth = maxZ - minZ + 1;

            const tileSize = 8;
            const xOffset = width / 2;
            const yOffset = height / 2 - (plotDepth * tileSize * Math.sin(ISO_ANGLE_Y)) / 2 + 10;

            for (let z = 0; z < plotDepth; z++) {
                for (let x = 0; x < plotWidth; x++) {
                    const worldX = minX + x;
                    const worldZ = minZ + z;

                    // Minecraft-like height calculation (Seed-based)
                    let heightValue = getSeededNoise(worldX, worldZ, 0.03, 5, 0.5, 2.0);
                    const terrainHeight = Math.floor(heightValue * 12); // Slightly more verticality

                    // Minecraft Palette
                    let topColor, sideColor;
                    if (heightValue < 0.25) { // Water
                        topColor = '#3F76E4';
                        sideColor = '#3461BC';
                    } else if (heightValue < 0.3) { // Sand/Beach
                        topColor = '#D1BA8A';
                        sideColor = '#B29E75';
                    } else if (heightValue < 0.6) { // Grassland
                        topColor = '#559028';
                        sideColor = '#416B1E';
                    } else if (heightValue < 0.8) { // Stone/Hills
                        topColor = '#7D7D7D';
                        sideColor = '#5C5C5C';
                    } else { // Snow/High Peaks
                        topColor = '#FFFFFF';
                        sideColor = '#D0D0D0';
                    }

                    const isoX = (x - z) * tileSize * Math.cos(ISO_ANGLE_X) + xOffset;
                    const isoY = (x + z) * tileSize * Math.sin(ISO_ANGLE_Y) - (terrainHeight * 2) + yOffset;

                    // Draw Top (Diamond)
                    ctx.fillStyle = topColor;
                    ctx.beginPath();
                    ctx.moveTo(isoX, isoY);
                    ctx.lineTo(isoX + tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX - tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                    ctx.closePath();
                    ctx.fill();

                    // Draw Sides for depth
                    ctx.fillStyle = sideColor;
                    // Left side
                    ctx.beginPath();
                    ctx.moveTo(isoX - tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y) + 4); // Small base for side
                    ctx.lineTo(isoX - tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y) + 4);
                    ctx.closePath();
                    ctx.fill();

                    // Right side
                    ctx.beginPath();
                    ctx.moveTo(isoX + tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y));
                    ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y) + 4);
                    ctx.lineTo(isoX + tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y) + 4);
                    ctx.closePath();
                    ctx.fill();

                    // Boundary Check
                    const isBoundary = (x === 0 || x === plotWidth - 1 || z === 0 || z === plotDepth - 1);
                    if (isBoundary) {
                        ctx.strokeStyle = '#FF0000';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(isoX, isoY);
                        ctx.lineTo(isoX + tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                        ctx.lineTo(isoX, isoY + tileSize * 2 * Math.sin(ISO_ANGLE_Y));
                        ctx.lineTo(isoX - tileSize * Math.cos(ISO_ANGLE_X), isoY + tileSize * Math.sin(ISO_ANGLE_Y));
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
            }
        }

        let dataPollingInterval;


        function startDataPolling() {
            stopDataPolling(); // Ensure no multiple intervals are running
            dataPollingInterval = setInterval(async () => {
                await loadData();
                if (document.getElementById('dashboard-view').classList.contains('active')) {
                    renderDashboard();
                }
            }, 5000); // Poll every 5 seconds
        }

        let landCardTimers = {}; // To store intervals for land card timers

        async function startLandCardCountdown(paymentCode, expirationTime, cost) {
            clearInterval(landCardTimers[paymentCode]); // Clear any existing timer for this paymentCode

            const timerElement = document.getElementById(`countdown-${paymentCode}`);
            const statusElement = document.getElementById(`status-${paymentCode}`);
            const paymentCommandElement = document.getElementById(`payment-command-${paymentCode}`);
            const copyButton = document.getElementById(`copy-code-button-${paymentCode}`);
            const paymentDetailsDiv = document.getElementById(`payment-details-${paymentCode}`);
            const cancelButton = document.getElementById(`cancel-payment-button-${paymentCode}`);

            if (!timerElement || !statusElement || !paymentCommandElement || !copyButton || !paymentDetailsDiv || !cancelButton) {
                console.warn(`Elements for paymentCode ${paymentCode} not found or land paid.`);
                return;
            }

            let durationInSeconds = Math.max(0, Math.ceil((expirationTime - new Date().getTime()) / 1000));
            // Show payment details if timer is active
            if (durationInSeconds > 0) {
                 paymentDetailsDiv.style.display = 'block';
            }


            const updateTimer = async () => {
                let minutes = parseInt(durationInSeconds / 60, 10);
                let seconds = parseInt(durationInSeconds % 60, 10);

                minutes = minutes < 10 ? "0" + minutes : minutes;
                seconds = seconds < 10 ? "0" + seconds : seconds;

                timerElement.textContent = `${minutes}:${seconds}`;

                if (durationInSeconds <= 0) {
                    clearInterval(landCardTimers[paymentCode]);
                    timerElement.textContent = 'Expired';
                    statusElement.textContent = 'Expired';
                    paymentDetailsDiv.style.display = 'none'; // Hide payment details on expiry
                    
                    // Call backend to cancel the expired land reservation if it wasn't paid
                    try {
                        const land = lands.find(l => l.paymentCode === paymentCode);
                        if (land && !land.paid) {
                            await fetch(`${API_URL}/cancel-payment`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ paymentCode })
                            });
                            await loadData(); // Reload data to reflect cancellation
                            renderDashboard(); // Re-render dashboard
                        }
                    } catch (e) {
                        console.error('Error cancelling expired payment on frontend:', e);
                    }
                } else {
                    durationInSeconds--;
                }
            };

            // Initial update
            updateTimer();
            landCardTimers[paymentCode] = setInterval(updateTimer, 1000);

            paymentCommandElement.textContent = `/land payment ${paymentCode}`;
            copyButton.onclick = () => {
                navigator.clipboard.writeText(`/land payment ${paymentCode}`).then(() => {
                    alert('Command copied to clipboard!');
                }).catch(() => {
                    // Silently fail if clipboard access is denied or fails
                });
            };

            cancelButton.onclick = async () => {
                clearInterval(landCardTimers[paymentCode]);
                showLoading('Cancelling payment...');
                try {
                    const response = await fetch(`${API_URL}/cancel-payment`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ paymentCode })
                    });
                    const result = await response.json();
                    if (result.success) {
                        showPaymentStatus(false, 'Payment Cancelled');
                        const audio = new Audio('https://www.soundjay.com/misc/sounds/fail-buzzer-02.mp3'); // A distinct failure sound
                        audio.play();
                        hasPendingPayment = false; // Set flag to false on cancellation
                        await loadData(); // Ensure local state is updated
                        renderDashboard(); // Go back to dashboard
                    } else {
                        showPaymentStatus(false, 'Failed to cancel payment.');
                    }
                } catch (e) {
                    showPaymentStatus(false, 'Error cancelling payment.');
                }
                hideLoading();
            };

            // Polling for payment status (similar to old fullscreen timer)
            let paymentPollingInterval = setInterval(async () => {
                await loadData(); // Load latest data
                const currentLand = lands.find(l => l.paymentCode === paymentCode);

                if (currentLand && currentLand.paid) {
                    clearInterval(landCardTimers[paymentCode]);
                    clearInterval(paymentPollingInterval);
                    showPaymentStatus(true, `Payment for land (${paymentCode}) successful!`);
                    hasPendingPayment = false; // Reset global flag
                    renderDashboard(); // Re-render dashboard to show updated status
                } else if (currentLand && currentLand.status === 'failed_insufficient_balance') {
                    // If payment fails due to insufficient balance, stop timers but keep card displayed
                    clearInterval(landCardTimers[paymentCode]);
                    clearInterval(paymentPollingInterval);
                    statusElement.textContent = 'Insufficient Balance';
                    paymentDetailsDiv.innerHTML += `
                        <p class="messages message-error">Insufficient balance. Please add funds in-game or cancel.</p>
                        <button id="cancel-failed-payment-button-${paymentCode}" class="button cancel-button">Cancel Reservation</button>
                    `;
                    document.getElementById(`cancel-failed-payment-button-${paymentCode}`).addEventListener('click', async () => {
                        showLoading('Cancelling reservation...');
                        await fetch(`${API_URL}/cancel-payment`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ paymentCode })
                        });
                        hideLoading();
                        showPaymentStatus(false, 'Reservation Cancelled');
                        await loadData();
                        renderDashboard();
                    });
                } else if (!currentLand && !hasPendingPayment) {
                     // If the land is no longer found (e.g., cancelled by plugin/backend), and there are no other pending payments
                     clearInterval(landCardTimers[paymentCode]);
                     clearInterval(paymentPollingInterval);
                     renderDashboard(); // Re-render to reflect the change
                }
            }, 5000); // Poll every 5 seconds
        }

        function stopDataPolling() {
            clearInterval(dataPollingInterval);
        }

        // --- View Switching ---
        function setView(viewId) {
            views.forEach(view => {
                view.classList.remove('active');
            });
            document.getElementById(viewId).classList.add('active');
        }

        // --- Rendering Functions ---
        function renderDashboard() {
            if (!currentUser) return;
            
            setView('dashboard-view');
            dashboardTitle.textContent = `Welcome, ${currentUser.minecraftName}!`; // Removed balance display
            
            // Check for government access
            govPanelButton.style.display = currentUser.minecraftName.toLowerCase() === 'minecraft2613' ? 'block' : 'none';

            // Disable Buy New Land button if there's a pending payment
            buyLandButton.disabled = hasPendingPayment;
            if (hasPendingPayment) {
                buyLandButton.textContent = 'Pending Payment...';
            } else {
                buyLandButton.textContent = 'Buy New Land';
            }

            // Filter lands for the current user and render them
            const userPlots = lands.filter(land => land.owner === currentUser.minecraftName);
            userLandsList.innerHTML = userPlots.map(renderLandCard).join('');

            // After rendering, activate any land card specific timers and render terrain maps
            userPlots.forEach(land => {
                if (!land.paid && land.paymentCode && new Date().getTime() < land.expirationTime) {
                    startLandCardCountdown(land.paymentCode, land.expirationTime, land.cost);
                }
                // Render the terrain map for each land
                const canvasId = `land-canvas-${land.paymentCode || land.id}`;
                renderTerrainMap(canvasId, land);
            });

            if (userPlots.length === 0) {
                userLandsList.innerHTML = '<p style="text-align: center; color: var(--text-dark);">You do not own any land yet.</p>';
            }
        }
        
        function renderBuyLand() {
            setView('buy-land-view');
            renderCoordinatesForm(buyLandForm, 2, 'player');
            const coordsInputs = buyLandForm.querySelectorAll('.coord-input');
            const liveCalculationCard = document.getElementById('live-calculation-card');

            // Add event listeners for live calculation
            coordsInputs.forEach(input => {
                input.addEventListener('input', () => {
                    const coords = getFormCoordinates(buyLandForm);
                    const calculatedDetails = calculatePlotDetails(coords);

                    if (calculatedDetails.isValid) {
                        liveCalculationCard.style.display = 'block';
                        document.getElementById('calc-blocks').textContent = calculatedDetails.blocks;
                        document.getElementById('calc-base-cost').textContent = calculatedDetails.baseCost.toFixed(2);
                        document.getElementById('calc-tax').textContent = calculatedDetails.tax.toFixed(2);
                        document.getElementById('calc-gst').textContent = calculatedDetails.gst.toFixed(2);
                        document.getElementById('calc-total-cost').textContent = calculatedDetails.cost.toFixed(2);
                    } else {
                        liveCalculationCard.style.display = 'none';
                    }
                });
            });
        }
        
        function renderGovPanel() {
            setView('gov-panel-view');
            renderCoordinatesForm(registerGovLandForm, 2, 'gov');
            
            // Populate settings form with current values
            document.getElementById('gov-gap').value = govConfig.gap;
            document.getElementById('gov-land-type').value = govConfig.landType;
            document.getElementById('gov-balance').textContent = governmentBalance.toFixed(2);
            
            // Render owner buttons
            const allOwners = [...new Set(lands.map(land => land.owner))];
            ownerButtonsContainer.innerHTML = allOwners.map(owner => `
                <button class="button" data-owner="${owner}">${owner}</button>
            `).join('');

            const paidLands = lands.filter(land => land.paid && land.cost > 0).sort((a, b) => b.purchaseTime - a.purchaseTime).slice(0, 5);
            const transactionList = document.getElementById('transaction-list');
            transactionList.innerHTML = paidLands.map(land => `<li>${land.owner} purchased land for ${land.cost.toFixed(2)}</li>`).join('');

            // Display plots for the currently selected player, or an empty message
            if (selectedPlayerForManagement) {
                displayPlayerPlots(selectedPlayerForManagement);
            } else {
                selectedPlayerPlotsContainer.innerHTML = '<p style="text-align: center; color: var(--text-dark);">Select a player to view their plots.</p>';
            }
        }
        
        function renderLandCard(land) {
            const isPending = !land.paid && land.paymentCode && (new Date().getTime() < land.expirationTime);
            const landStatusClass = land.paid ? 'status-paid' : (isPending ? 'status-pending' : 'status-expired');
            const landStatusText = land.paid ? 'Paid' : (isPending ? 'Pending' : 'Expired');

            // Determine if the land has failed due to insufficient balance
            const isFailedInsufficientBalance = !land.paid && land.status === 'failed_insufficient_balance';
            
            const cardHtml = `
                <div class="land-card">
                    <canvas id="land-canvas-${land.paymentCode || land.id}" class="land-map-canvas"></canvas>
                    <div class="land-details">
                        <h3>Plot Owner: ${land.owner}</h3>
                        <p>Blocks: <span class="detail-value">${land.blocks}</span></p>
                        <p>Type: <span class="detail-value">${land.landType}</span></p>
                        ${land.cost > 0 ? `<p>Cost: $<span class="detail-value">${land.cost.toFixed(2)}</span></p>` : ''}
                        <p>Status: <span class="detail-value ${landStatusClass}">${landStatusText}</span></p>
                    </div>
                    ${isPending ? `
                        <div id="payment-details-${land.paymentCode}" class="pending-payment-section">
                            <h4>Complete Payment</h4>
                            <p>Command: <code><span id="payment-command-${land.paymentCode}"></span> <button class="copy-button button" id="copy-code-button-${land.paymentCode}">Copy</button></code></p>
                            <p>Time Left: <span id="countdown-${land.paymentCode}" class="timer-display"></span></p>
                            <button class="cancel-button button" id="cancel-payment-button-${land.paymentCode}">Cancel Reservation</button>
                        </div>
                    ` : ''}
                    ${isFailedInsufficientBalance ? `
                        <div class="pending-payment-section">
                            <p class="messages message-error">Insufficient balance. Add funds in-game or cancel.</p>
                            <button class="cancel-button button" id="cancel-failed-payment-button-${land.paymentCode}">Cancel Reservation</button>
                        </div>
                    ` : ''}
                </div>
            `;

            // Since renderLandCard is called inside map, we can't directly call renderTerrainMap here.
            // We will need to call renderTerrainMap after the DOM is updated in renderDashboard.
            return cardHtml;
        }
        
        function renderCoordinatesForm(formElement, count, type) {
            const formGrid = formElement.querySelector('.form-grid') || formElement;
            let html = `
                <div class="form-group">
                    <label>Corner 1 (e.g., North-West)</label>
                    <input type="number" name="${type}-coord-x-1" placeholder="X" class="coord-input" required>
                    <input type="number" name="${type}-coord-y-1" placeholder="Y" class="coord-input" required>
                    <input type="number" name="${type}-coord-z-1" placeholder="Z" class="coord-input" required>
                </div>
                <div class="form-group">
                    <label>Corner 2 (e.g., South-East)</label>
                    <input type="number" name="${type}-coord-x-2" placeholder="X" class="coord-input" required>
                    <input type="number" name="${type}-coord-y-2" placeholder="Y" class="coord-input" required>
                    <input type="number" name="${type}-coord-z-2" placeholder="Z" class="coord-input" required>
                </div>
            `;
            formGrid.innerHTML = html;
        }

        function getFormCoordinates(formElement, count = 2, prefix = 'player-coord') {
            const coords = [];
            for (let i = 1; i <= count; i++) {
                const x = formElement.querySelector(`input[name="${prefix}-x-${i}"]`)?.value;
                const y = formElement.querySelector(`input[name="${prefix}-y-${i}"]`)?.value;
                const z = formElement.querySelector(`input[name="${prefix}-z-${i}"]`)?.value;
                coords.push({ x, y, z });
            }
            return coords;
        }

        function displayPlayerPlots(owner) {
            selectedPlayerForManagement = owner;
            const playerPlots = lands.filter(land => land.owner === owner);
            selectedPlayerPlotsContainer.innerHTML = playerPlots.map(renderLandCard).join('');
        }

        // --- Event Listeners ---
        loginForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const minecraftName = document.getElementById('name').value.trim();
            const minecraftEdition = document.getElementById('edition').value;
            
            if (!minecraftName) {
                showMessage(loginMessages, 'Please enter a Minecraft name.', 'error');
                return;
            }

            showLoading('Logging in...');
            await loadData(); // Load latest data before login

            let existingUser = users.find(u => u.minecraftName === minecraftName && u.minecraftEdition === minecraftEdition);
            if (existingUser) {
                currentUser = existingUser;
            } else {
                currentUser = { minecraftName, minecraftEdition, wallet: 1000.00 }; // Default starting balance
                users.push(currentUser);
            }

            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            await saveData();
            hideLoading();
            renderDashboard();
            startDataPolling();
        });

        logoutButton.addEventListener('click', () => {
            currentUser = null;
            localStorage.removeItem('currentUser');
            stopDataPolling();
            setView('login-view');
        });

        buyLandButton.addEventListener('click', () => renderBuyLand());
        govPanelButton.addEventListener('click', () => renderGovPanel());
        backFromBuyButton.addEventListener('click', () => renderDashboard());
        backFromGovButton.addEventListener('click', () => renderDashboard());

        buyLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            if (hasPendingPayment) {
                showMessage(buyLandMessages, 'You have a pending land reservation. Please complete or cancel it first.', 'error');
                return;
            }

            const button = buyLandSubmitButton;
            button.disabled = true;

            try {
                const coords = getFormCoordinates(buyLandForm, 2, 'player-coord');
                const calculatedDetails = calculatePlotDetails(coords);

                if (!calculatedDetails.isValid) {
                    showMessage(buyLandMessages, 'Please enter valid numeric coordinates for both points.', 'error');
                    return;
                }

                if (calculatedDetails.blocks > MAX_PLAYER_LAND_BLOCKS) {
                    showMessage(buyLandMessages, `Plot is too large. Max size is ${MAX_PLAYER_LAND_BLOCKS} blocks.`, 'error');
                    return;
                }
                
                const newCoords = coords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
                const isCollision = isColliding(newCoords, lands, 'Player', PLAYER_PLOT_GAP);
                if (isCollision) {
                    hideLoading();
                    return;
                }

                showLoading('Reserving land...');
                const response = await fetch(`${API_URL}/reserve-land-web`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        owner: currentUser.minecraftName,
                        coords: newCoords,
                        blocks: calculatedDetails.blocks,
                        cost: calculatedDetails.cost,
                        baseCost: calculatedDetails.baseCost,
                        tax: calculatedDetails.tax,
                        gst: calculatedDetails.gst,
                        gap: PLAYER_PLOT_GAP,
                        landType: 'Player'
                    })
                });

                const result = await response.json();

                if (result.success) {
                    hideLoading();
                    hasPendingPayment = true; // Set flag for pending payment
                    await loadData(); // Reload data to get the newly reserved land
                    renderDashboard(); // Render dashboard to show the pending land card
                    showMessage(buyLandMessages, 'Land reserved! Complete payment in-game.', 'success');
                } else {
                    hideLoading();
                    showPaymentStatus(false, result.message || 'An error occurred during reservation.');
                }

            } catch (error) {
                hideLoading();
                showPaymentStatus(false, 'An error occurred during reservation.');
            } finally {
                button.disabled = false;
            }
        });

        govSettingsForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newGap = parseInt(document.getElementById('gov-gap').value, 10);
            const newLandType = document.getElementById('gov-land-type').value.trim();

            if (isNaN(newGap) || newGap < 0) {
                showMessage(govPanelMessages, 'Please enter a valid gap.', 'error');
                return;
            }
            if (!newLandType) {
                showMessage(govPanelMessages, 'Please enter a valid land type.', 'error');
                return;
            }

            govConfig.gap = newGap;
            govConfig.landType = newLandType;
            await saveData();
            showMessage(govPanelMessages, 'Government settings updated successfully!', 'success');
            renderGovPanel();
        });

        registerGovLandForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const button = registerGovLandSubmitButton;
            button.disabled = true;

            try {
                const govCoords = getFormCoordinates(registerGovLandForm, 2, 'gov-coord');
                const calculatedDetails = calculatePlotDetails(govCoords);
                const govLandGap = parseInt(document.getElementById('gov-land-gap').value, 10);

                if (!calculatedDetails.isValid) {
                    showMessage(govPanelMessages, 'Please enter valid numeric coordinates for both points.', 'error');
                    return;
                }

                if (isNaN(govLandGap) || govLandGap < 0) {
                    showMessage(govPanelMessages, 'Please enter a valid gap for player lands.', 'error');
                    return;
                }

                const newCoords = govCoords.map(c => ({ x: parseFloat(c.x), y: parseFloat(c.y), z: parseFloat(c.z) }));
                const isCollision = isColliding(newCoords, lands, govConfig.landType, govConfig.gap);
                if (isCollision) {
                    return;
                }

                const newLand = {
                    owner: currentUser.minecraftName,
                    coords: newCoords,
                    blocks: calculatedDetails.blocks,
                    cost: 0, // Government lands are free
                    gap: govLandGap, // Use the dynamically defined gap
                    landType: govConfig.landType,
                    paymentCode: null, // No payment needed
                    purchaseTime: new Date().getTime(),
                    paid: true // Marked as paid instantly
                };

                lands.push(newLand);
                await saveData();
                showMessage(govPanelMessages, `Successfully registered new government land: ${govConfig.landType}!`, 'success');
                renderGovPanel();
            } catch (error) {
                showMessage(govPanelMessages, 'An error occurred while processing your request.', 'error');
            } finally {
                button.disabled = false;
            }
        });

        ownerButtonsContainer.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (button && button.dataset.owner) {
                displayPlayerPlots(button.dataset.owner);
            }
        });
        
        

        document.getElementById('copy-code-button').addEventListener('click', () => {
            const paymentCode = document.getElementById('payment-code').textContent;
            navigator.clipboard.writeText(`/land payment ${paymentCode}`).then(() => {
                alert('Command copied to clipboard!');
                }).catch(() => {
                    // Silently fail if clipboard access is denied or fails
                });
        });

        document.addEventListener('DOMContentLoaded', async () => {
            const savedUser = localStorage.getItem('currentUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                await loadData();
                renderDashboard();
            } else {
                setView('login-view');
            }
        });
    </script>
</body>
</html>